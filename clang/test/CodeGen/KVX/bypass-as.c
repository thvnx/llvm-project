// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py
// RUN: %clang_cc1 -triple kvx-kalray-cos -O3 -S %s -o - -emit-llvm | FileCheck %s

typedef int v4i32 __attribute__((vector_size(4 * sizeof(int))));
typedef float v2f32 __attribute__((vector_size(2 * sizeof(float))));
typedef float v4f32 __attribute__((vector_size(4 * sizeof(float))));

struct S {
  int a;
  int b;
  int c;
  int d;
};

// CHECK-LABEL: @bypass_i8(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = load i8, i8 addrspace(256)* [[I:%.*]], align 1, !tbaa !2
// CHECK-NEXT:    ret i8 [[TMP0]]
//
char bypass_i8(__bypass char *i) {
  return *i;
}

// CHECK-LABEL: @bypass_i16(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = load i16, i16 addrspace(256)* [[I:%.*]], align 2, !tbaa !5
// CHECK-NEXT:    ret i16 [[TMP0]]
//
short bypass_i16(__bypass short *i) {
  return *i;
}

// CHECK-LABEL: @bypass_i32(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = load i32, i32 addrspace(256)* [[I:%.*]], align 4, !tbaa !7
// CHECK-NEXT:    ret i32 [[TMP0]]
//
int bypass_i32(__bypass int *i) {
  return *i;
}

// CHECK-LABEL: @bypass_i64(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = load i64, i64 addrspace(256)* [[I:%.*]], align 8, !tbaa !9
// CHECK-NEXT:    ret i64 [[TMP0]]
//
long bypass_i64(__bypass long *i) {
  return *i;
}

// CHECK-LABEL: @fbypass_f32(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = load float, float addrspace(256)* [[F:%.*]], align 4, !tbaa !11
// CHECK-NEXT:    ret float [[TMP0]]
//
float fbypass_f32(__bypass float *f) {
  return *f;
}

// CHECK-LABEL: @fbypass_f64(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = load double, double addrspace(256)* [[D:%.*]], align 8, !tbaa !13
// CHECK-NEXT:    ret double [[TMP0]]
//
double fbypass_f64(__bypass double *d) {
  return *d;
}

// CHECK-LABEL: @fbypass_v2f32(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = load <2 x float>, <2 x float> addrspace(256)* [[V:%.*]], align 8, !tbaa !2
// CHECK-NEXT:    ret <2 x float> [[TMP0]]
//
v2f32 fbypass_v2f32(__bypass v2f32 *v) {
  return *v;
}

// CHECK-LABEL: @fbypass_v4f32(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = load <4 x float>, <4 x float> addrspace(256)* [[V:%.*]], align 16, !tbaa !2
// CHECK-NEXT:    ret <4 x float> [[TMP0]]
//
v4f32 fbypass_v4f32(__bypass v4f32 *v) {
  return *v;
}

// CHECK-LABEL: @foo_bypass_a(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[A:%.*]] = getelementptr inbounds [[STRUCT_S:%.*]], [[STRUCT_S]] addrspace(256)* [[S:%.*]], i64 0, i32 0
// CHECK-NEXT:    [[TMP0:%.*]] = load i32, i32 addrspace(256)* [[A]], align 4, !tbaa !15
// CHECK-NEXT:    ret i32 [[TMP0]]
//
int foo_bypass_a(__bypass struct S *s) {
  return s->a;
}

// CHECK-LABEL: @foo_bypass_b(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[B:%.*]] = getelementptr inbounds [[STRUCT_S:%.*]], [[STRUCT_S]] addrspace(256)* [[S:%.*]], i64 0, i32 1
// CHECK-NEXT:    [[TMP0:%.*]] = load i32, i32 addrspace(256)* [[B]], align 4, !tbaa !17
// CHECK-NEXT:    ret i32 [[TMP0]]
//
int foo_bypass_b(__bypass struct S *s) {
  return s->b;
}

// CHECK-LABEL: @foo_bypass_c(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[C:%.*]] = getelementptr inbounds [[STRUCT_S:%.*]], [[STRUCT_S]] addrspace(256)* [[S:%.*]], i64 0, i32 2
// CHECK-NEXT:    [[TMP0:%.*]] = load i32, i32 addrspace(256)* [[C]], align 4, !tbaa !18
// CHECK-NEXT:    ret i32 [[TMP0]]
//
int foo_bypass_c(__bypass struct S *s) {
  return s->c;
}

// CHECK-LABEL: @foo_bypass_d(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[D:%.*]] = getelementptr inbounds [[STRUCT_S:%.*]], [[STRUCT_S]] addrspace(256)* [[S:%.*]], i64 0, i32 3
// CHECK-NEXT:    [[TMP0:%.*]] = load i32, i32 addrspace(256)* [[D]], align 4, !tbaa !19
// CHECK-NEXT:    ret i32 [[TMP0]]
//
int foo_bypass_d(__bypass struct S *s) {
  return s->d;
}

// CHECK-LABEL: @foo_bypass_3(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = load <4 x i32>, <4 x i32> addrspace(256)* [[V:%.*]], align 16, !tbaa !2
// CHECK-NEXT:    [[VECEXT:%.*]] = extractelement <4 x i32> [[TMP0]], i32 3
// CHECK-NEXT:    ret i32 [[VECEXT]]
//
int foo_bypass_3(__bypass v4i32 *v) {
  return (*v)[3];
}

// CHECK-LABEL: @foo_bypass_x(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = load <4 x i32>, <4 x i32> addrspace(256)* [[V:%.*]], align 16, !tbaa !2
// CHECK-NEXT:    [[VECEXT:%.*]] = extractelement <4 x i32> [[TMP0]], i32 [[X:%.*]]
// CHECK-NEXT:    ret i32 [[VECEXT]]
//
int foo_bypass_x(__bypass v4i32 *v, int x) {
  return (*v)[x];
}

// CHECK-LABEL: @foo_default(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = load i32, i32* [[I:%.*]], align 4, !tbaa !7
// CHECK-NEXT:    ret i32 [[TMP0]]
//
int foo_default(int *i) {
  return *i;
}

// CHECK-LABEL: @foo_default_a(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[A:%.*]] = getelementptr inbounds [[STRUCT_S:%.*]], %struct.S* [[S:%.*]], i64 0, i32 0
// CHECK-NEXT:    [[TMP0:%.*]] = load i32, i32* [[A]], align 4, !tbaa !15
// CHECK-NEXT:    ret i32 [[TMP0]]
//
int foo_default_a(struct S *s) {
  return s->a;
}

// CHECK-LABEL: @foo_default_b(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[B:%.*]] = getelementptr inbounds [[STRUCT_S:%.*]], %struct.S* [[S:%.*]], i64 0, i32 1
// CHECK-NEXT:    [[TMP0:%.*]] = load i32, i32* [[B]], align 4, !tbaa !17
// CHECK-NEXT:    ret i32 [[TMP0]]
//
int foo_default_b(struct S *s) {
  return s->b;
}

// CHECK-LABEL: @foo_default_c(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[C:%.*]] = getelementptr inbounds [[STRUCT_S:%.*]], %struct.S* [[S:%.*]], i64 0, i32 2
// CHECK-NEXT:    [[TMP0:%.*]] = load i32, i32* [[C]], align 4, !tbaa !18
// CHECK-NEXT:    ret i32 [[TMP0]]
//
int foo_default_c(struct S *s) {
  return s->c;
}

// CHECK-LABEL: @foo_default_d(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[D:%.*]] = getelementptr inbounds [[STRUCT_S:%.*]], %struct.S* [[S:%.*]], i64 0, i32 3
// CHECK-NEXT:    [[TMP0:%.*]] = load i32, i32* [[D]], align 4, !tbaa !19
// CHECK-NEXT:    ret i32 [[TMP0]]
//
int foo_default_d(struct S *s) {
  return s->d;
}

// CHECK-LABEL: @foo_default_3(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = load <4 x i32>, <4 x i32>* [[V:%.*]], align 16, !tbaa !2
// CHECK-NEXT:    [[VECEXT:%.*]] = extractelement <4 x i32> [[TMP0]], i32 3
// CHECK-NEXT:    ret i32 [[VECEXT]]
//
int foo_default_3(v4i32 *v) {
  return (*v)[3];
}

// CHECK-LABEL: @foo_default_x(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[TMP0:%.*]] = load <4 x i32>, <4 x i32>* [[V:%.*]], align 16, !tbaa !2
// CHECK-NEXT:    [[VECEXT:%.*]] = extractelement <4 x i32> [[TMP0]], i32 [[X:%.*]]
// CHECK-NEXT:    ret i32 [[VECEXT]]
//
int foo_default_x(v4i32 *v, int x) {
  return (*v)[x];
}

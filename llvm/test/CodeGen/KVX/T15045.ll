; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc -O3 -asm-verbose=false < %s -mtriple=kvx-kalray-cos | FileCheck %s

; This test is a minimal reproducer for T15045.

; Original C code is:

; void a() {
;   int *b;
;   while (!__sync_bool_compare_and_swap(&b, 0, 0))
;     *(volatile long *)0;
; }

target triple = "kvx-kalray-cos"

define void @_Z1av() {
; CHECK-LABEL: _Z1av:
; CHECK:         addd $r12 = $r12, -32
; CHECK-NEXT:    fence
; CHECK-NEXT:    make $r0 = 0
; CHECK-NEXT:    ;;
; CHECK-NEXT:    .cfi_def_cfa_offset 32
; CHECK-NEXT:    copyd $r3 = $r0
; CHECK-NEXT:    ;;
; CHECK-NEXT:  .LBB0_11:
; CHECK-NEXT:    copyd $r2 = $r0
; CHECK-NEXT:    ;;
; CHECK-NEXT:    acswapd 0[$r12] = $r2r3
; CHECK-NEXT:    ;;
; CHECK-NEXT:    cb.odd $r2 ? .LBB0_12
; CHECK-NEXT:    ;;
; CHECK-NEXT:    ld.u $r1 = 0[$r12]
; CHECK-NEXT:    ;;
; CHECK-NEXT:    compd.eq $r2 = $r1, $r3
; CHECK-NEXT:    ;;
; CHECK-NEXT:    cb.odd $r2 ? .LBB0_11
; CHECK-NEXT:    ;;
; CHECK-NEXT:    goto .LBB0_13
; CHECK-NEXT:    ;;
; CHECK-NEXT:  .LBB0_12:
; CHECK-NEXT:    copyd $r1 = $r3
; CHECK-NEXT:    ;;
; CHECK-NEXT:  .LBB0_13:
; CHECK-NEXT:    cb.deqz $r1 ? .LBB0_10
; CHECK-NEXT:    ;;
; CHECK-NEXT:  .LBB0_2:
; CHECK-NEXT:    make $r0 = 0
; CHECK-NEXT:    ;;
; CHECK-NEXT:    ld $r1 = 0[$r0]
; CHECK-NEXT:    ;;
; CHECK-NEXT:    fence
; CHECK-NEXT:    copyd $r3 = $r0
; CHECK-NEXT:    ;;
; CHECK-NEXT:  .LBB0_14:
; CHECK-NEXT:    copyd $r2 = $r0
; CHECK-NEXT:    ;;
; CHECK-NEXT:    acswapd 0[$r12] = $r2r3
; CHECK-NEXT:    ;;
; CHECK-NEXT:    cb.odd $r2 ? .LBB0_15
; CHECK-NEXT:    ;;
; CHECK-NEXT:    ld.u $r1 = 0[$r12]
; CHECK-NEXT:    ;;
; CHECK-NEXT:    compd.eq $r2 = $r1, $r3
; CHECK-NEXT:    ;;
; CHECK-NEXT:    cb.odd $r2 ? .LBB0_14
; CHECK-NEXT:    ;;
; CHECK-NEXT:    goto .LBB0_16
; CHECK-NEXT:    ;;
; CHECK-NEXT:  .LBB0_15:
; CHECK-NEXT:    copyd $r1 = $r3
; CHECK-NEXT:    ;;
; CHECK-NEXT:  .LBB0_16:
; CHECK-NEXT:    compd.eq $r0 = $r1, 0
; CHECK-NEXT:    ;;
; CHECK-NEXT:    cb.odd $r0 ? .LBB0_10
; CHECK-NEXT:    ;;
; CHECK-NEXT:    make $r0 = 0
; CHECK-NEXT:    ;;
; CHECK-NEXT:    ld $r1 = 0[$r0]
; CHECK-NEXT:    ;;
; CHECK-NEXT:    fence
; CHECK-NEXT:    copyd $r3 = $r0
; CHECK-NEXT:    ;;
; CHECK-NEXT:  .LBB0_17:
; CHECK-NEXT:    copyd $r2 = $r0
; CHECK-NEXT:    ;;
; CHECK-NEXT:    acswapd 0[$r12] = $r2r3
; CHECK-NEXT:    ;;
; CHECK-NEXT:    cb.odd $r2 ? .LBB0_18
; CHECK-NEXT:    ;;
; CHECK-NEXT:    ld.u $r1 = 0[$r12]
; CHECK-NEXT:    ;;
; CHECK-NEXT:    compd.eq $r2 = $r1, $r3
; CHECK-NEXT:    ;;
; CHECK-NEXT:    cb.odd $r2 ? .LBB0_17
; CHECK-NEXT:    ;;
; CHECK-NEXT:    goto .LBB0_19
; CHECK-NEXT:    ;;
; CHECK-NEXT:  .LBB0_18:
; CHECK-NEXT:    copyd $r1 = $r3
; CHECK-NEXT:    ;;
; CHECK-NEXT:  .LBB0_19:
; CHECK-NEXT:    cb.deqz $r1 ? .LBB0_10
; CHECK-NEXT:    ;;
; CHECK-NEXT:    make $r0 = 0
; CHECK-NEXT:    ;;
; CHECK-NEXT:    ld $r1 = 0[$r0]
; CHECK-NEXT:    ;;
; CHECK-NEXT:    fence
; CHECK-NEXT:    copyd $r3 = $r0
; CHECK-NEXT:    ;;
; CHECK-NEXT:  .LBB0_20:
; CHECK-NEXT:    copyd $r2 = $r0
; CHECK-NEXT:    ;;
; CHECK-NEXT:    acswapd 0[$r12] = $r2r3
; CHECK-NEXT:    ;;
; CHECK-NEXT:    cb.odd $r2 ? .LBB0_21
; CHECK-NEXT:    ;;
; CHECK-NEXT:    ld.u $r1 = 0[$r12]
; CHECK-NEXT:    ;;
; CHECK-NEXT:    compd.eq $r2 = $r1, $r3
; CHECK-NEXT:    ;;
; CHECK-NEXT:    cb.odd $r2 ? .LBB0_20
; CHECK-NEXT:    ;;
; CHECK-NEXT:    goto .LBB0_22
; CHECK-NEXT:    ;;
; CHECK-NEXT:  .LBB0_21:
; CHECK-NEXT:    copyd $r1 = $r3
; CHECK-NEXT:    ;;
; CHECK-NEXT:  .LBB0_22:
; CHECK-NEXT:    cb.deqz $r1 ? .LBB0_10
; CHECK-NEXT:    ;;
; CHECK-NEXT:    make $r0 = 0
; CHECK-NEXT:    ;;
; CHECK-NEXT:    ld $r1 = 0[$r0]
; CHECK-NEXT:    ;;
; CHECK-NEXT:    fence
; CHECK-NEXT:    copyd $r3 = $r0
; CHECK-NEXT:    ;;
; CHECK-NEXT:  .LBB0_23:
; CHECK-NEXT:    copyd $r2 = $r0
; CHECK-NEXT:    ;;
; CHECK-NEXT:    acswapd 0[$r12] = $r2r3
; CHECK-NEXT:    ;;
; CHECK-NEXT:    cb.odd $r2 ? .LBB0_24
; CHECK-NEXT:    ;;
; CHECK-NEXT:    ld.u $r1 = 0[$r12]
; CHECK-NEXT:    ;;
; CHECK-NEXT:    compd.eq $r2 = $r1, $r3
; CHECK-NEXT:    ;;
; CHECK-NEXT:    cb.odd $r2 ? .LBB0_23
; CHECK-NEXT:    ;;
; CHECK-NEXT:    goto .LBB0_25
; CHECK-NEXT:    ;;
; CHECK-NEXT:  .LBB0_24:
; CHECK-NEXT:    copyd $r1 = $r3
; CHECK-NEXT:    ;;
; CHECK-NEXT:  .LBB0_25:
; CHECK-NEXT:    cb.deqz $r1 ? .LBB0_10
; CHECK-NEXT:    ;;
; CHECK-NEXT:    make $r0 = 0
; CHECK-NEXT:    ;;
; CHECK-NEXT:    ld $r1 = 0[$r0]
; CHECK-NEXT:    ;;
; CHECK-NEXT:    fence
; CHECK-NEXT:    copyd $r3 = $r0
; CHECK-NEXT:    ;;
; CHECK-NEXT:  .LBB0_26:
; CHECK-NEXT:    copyd $r2 = $r0
; CHECK-NEXT:    ;;
; CHECK-NEXT:    acswapd 0[$r12] = $r2r3
; CHECK-NEXT:    ;;
; CHECK-NEXT:    cb.odd $r2 ? .LBB0_27
; CHECK-NEXT:    ;;
; CHECK-NEXT:    ld.u $r1 = 0[$r12]
; CHECK-NEXT:    ;;
; CHECK-NEXT:    compd.eq $r2 = $r1, $r3
; CHECK-NEXT:    ;;
; CHECK-NEXT:    cb.odd $r2 ? .LBB0_26
; CHECK-NEXT:    ;;
; CHECK-NEXT:    goto .LBB0_28
; CHECK-NEXT:    ;;
; CHECK-NEXT:  .LBB0_27:
; CHECK-NEXT:    copyd $r1 = $r3
; CHECK-NEXT:    ;;
; CHECK-NEXT:  .LBB0_28:
; CHECK-NEXT:    cb.deqz $r1 ? .LBB0_10
; CHECK-NEXT:    ;;
; CHECK-NEXT:    make $r0 = 0
; CHECK-NEXT:    ;;
; CHECK-NEXT:    ld $r1 = 0[$r0]
; CHECK-NEXT:    ;;
; CHECK-NEXT:    fence
; CHECK-NEXT:    copyd $r3 = $r0
; CHECK-NEXT:    ;;
; CHECK-NEXT:  .LBB0_29:
; CHECK-NEXT:    copyd $r2 = $r0
; CHECK-NEXT:    ;;
; CHECK-NEXT:    acswapd 0[$r12] = $r2r3
; CHECK-NEXT:    ;;
; CHECK-NEXT:    cb.odd $r2 ? .LBB0_30
; CHECK-NEXT:    ;;
; CHECK-NEXT:    ld.u $r1 = 0[$r12]
; CHECK-NEXT:    ;;
; CHECK-NEXT:    compd.eq $r2 = $r1, $r3
; CHECK-NEXT:    ;;
; CHECK-NEXT:    cb.odd $r2 ? .LBB0_29
; CHECK-NEXT:    ;;
; CHECK-NEXT:    goto .LBB0_31
; CHECK-NEXT:    ;;
; CHECK-NEXT:  .LBB0_30:
; CHECK-NEXT:    copyd $r1 = $r3
; CHECK-NEXT:    ;;
; CHECK-NEXT:  .LBB0_31:
; CHECK-NEXT:    cb.deqz $r1 ? .LBB0_10
; CHECK-NEXT:    ;;
; CHECK-NEXT:    make $r0 = 0
; CHECK-NEXT:    ;;
; CHECK-NEXT:    ld $r1 = 0[$r0]
; CHECK-NEXT:    ;;
; CHECK-NEXT:    fence
; CHECK-NEXT:    copyd $r3 = $r0
; CHECK-NEXT:    ;;
; CHECK-NEXT:  .LBB0_32:
; CHECK-NEXT:    copyd $r2 = $r0
; CHECK-NEXT:    ;;
; CHECK-NEXT:    acswapd 0[$r12] = $r2r3
; CHECK-NEXT:    ;;
; CHECK-NEXT:    cb.odd $r2 ? .LBB0_33
; CHECK-NEXT:    ;;
; CHECK-NEXT:    ld.u $r1 = 0[$r12]
; CHECK-NEXT:    ;;
; CHECK-NEXT:    compd.eq $r2 = $r1, $r3
; CHECK-NEXT:    ;;
; CHECK-NEXT:    cb.odd $r2 ? .LBB0_32
; CHECK-NEXT:    ;;
; CHECK-NEXT:    goto .LBB0_34
; CHECK-NEXT:    ;;
; CHECK-NEXT:  .LBB0_33:
; CHECK-NEXT:    copyd $r1 = $r3
; CHECK-NEXT:    ;;
; CHECK-NEXT:  .LBB0_34:
; CHECK-NEXT:    cb.deqz $r1 ? .LBB0_10
; CHECK-NEXT:    ;;
; CHECK-NEXT:    make $r0 = 0
; CHECK-NEXT:    ;;
; CHECK-NEXT:    ld $r1 = 0[$r0]
; CHECK-NEXT:    ;;
; CHECK-NEXT:    fence
; CHECK-NEXT:    copyd $r3 = $r0
; CHECK-NEXT:    ;;
; CHECK-NEXT:  .LBB0_35:
; CHECK-NEXT:    copyd $r2 = $r0
; CHECK-NEXT:    ;;
; CHECK-NEXT:    acswapd 0[$r12] = $r2r3
; CHECK-NEXT:    ;;
; CHECK-NEXT:    cb.odd $r2 ? .LBB0_36
; CHECK-NEXT:    ;;
; CHECK-NEXT:    ld.u $r1 = 0[$r12]
; CHECK-NEXT:    ;;
; CHECK-NEXT:    compd.eq $r2 = $r1, $r3
; CHECK-NEXT:    ;;
; CHECK-NEXT:    cb.odd $r2 ? .LBB0_35
; CHECK-NEXT:    ;;
; CHECK-NEXT:    goto .LBB0_37
; CHECK-NEXT:    ;;
; CHECK-NEXT:  .LBB0_36:
; CHECK-NEXT:    copyd $r1 = $r3
; CHECK-NEXT:    ;;
; CHECK-NEXT:  .LBB0_37:
; CHECK-NEXT:    cb.dnez $r1 ? .LBB0_2
; CHECK-NEXT:    ;;
; CHECK-NEXT:  .LBB0_10:
; CHECK-NEXT:    addd $r12 = $r12, 32
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %b = alloca i32*, align 8
  %0 = bitcast i32** %b to i8*
  call void @llvm.lifetime.start.p0i8(i64 8, i8* nonnull %0)
  %1 = bitcast i32** %b to i64*
  %2 = cmpxchg i64* %1, i64 0, i64 0 seq_cst seq_cst
  %3 = extractvalue { i64, i1 } %2, 1
  br i1 %3, label %while.end, label %while.body

while.body:                                       ; preds = %entry, %while.body.7
  %4 = load volatile i64, i64* null, align 536870912
  %5 = cmpxchg i64* %1, i64 0, i64 0 seq_cst seq_cst
  %6 = extractvalue { i64, i1 } %5, 1
  br i1 %6, label %while.end, label %while.body.1

while.end:                                        ; preds = %while.body, %while.body.1, %while.body.2, %while.body.3, %while.body.4, %while.body.5, %while.body.6, %while.body.7, %entry
  call void @llvm.lifetime.end.p0i8(i64 8, i8* nonnull %0)
  ret void

while.body.1:                                     ; preds = %while.body
  %7 = load volatile i64, i64* null, align 536870912
  %8 = cmpxchg i64* %1, i64 0, i64 0 seq_cst seq_cst
  %9 = extractvalue { i64, i1 } %8, 1
  br i1 %9, label %while.end, label %while.body.2

while.body.2:                                     ; preds = %while.body.1
  %10 = load volatile i64, i64* null, align 536870912
  %11 = cmpxchg i64* %1, i64 0, i64 0 seq_cst seq_cst
  %12 = extractvalue { i64, i1 } %11, 1
  br i1 %12, label %while.end, label %while.body.3

while.body.3:                                     ; preds = %while.body.2
  %13 = load volatile i64, i64* null, align 536870912
  %14 = cmpxchg i64* %1, i64 0, i64 0 seq_cst seq_cst
  %15 = extractvalue { i64, i1 } %14, 1
  br i1 %15, label %while.end, label %while.body.4

while.body.4:                                     ; preds = %while.body.3
  %16 = load volatile i64, i64* null, align 536870912
  %17 = cmpxchg i64* %1, i64 0, i64 0 seq_cst seq_cst
  %18 = extractvalue { i64, i1 } %17, 1
  br i1 %18, label %while.end, label %while.body.5

while.body.5:                                     ; preds = %while.body.4
  %19 = load volatile i64, i64* null, align 536870912
  %20 = cmpxchg i64* %1, i64 0, i64 0 seq_cst seq_cst
  %21 = extractvalue { i64, i1 } %20, 1
  br i1 %21, label %while.end, label %while.body.6

while.body.6:                                     ; preds = %while.body.5
  %22 = load volatile i64, i64* null, align 536870912
  %23 = cmpxchg i64* %1, i64 0, i64 0 seq_cst seq_cst
  %24 = extractvalue { i64, i1 } %23, 1
  br i1 %24, label %while.end, label %while.body.7

while.body.7:                                     ; preds = %while.body.6
  %25 = load volatile i64, i64* null, align 536870912
  %26 = cmpxchg i64* %1, i64 0, i64 0 seq_cst seq_cst
  %27 = extractvalue { i64, i1 } %26, 1
  br i1 %27, label %while.end, label %while.body
}

declare void @llvm.lifetime.start.p0i8(i64 immarg, i8* nocapture)
declare void @llvm.lifetime.end.p0i8(i64 immarg, i8* nocapture)

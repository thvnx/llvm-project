; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc < %s -O2 | FileCheck %s
target triple = "kvx-kalray-cos"

define <2 x i32> @ctzwp(<2 x i32> %v){
; CHECK-LABEL: ctzwp:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    ctzwp $r0 = $r0
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = tail call <2 x i32> @llvm.kvx.ctzwp(<2 x i32> %v)
  ret <2 x i32> %0
}

declare <2 x i32> @llvm.kvx.ctzwp(<2 x i32>) #1

define <2 x i32> @clzwp(<2 x i32> %v){
; CHECK-LABEL: clzwp:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    clzwp $r0 = $r0
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = tail call <2 x i32> @llvm.kvx.clzwp(<2 x i32> %v)
  ret <2 x i32> %0
}

declare <2 x i32> @llvm.kvx.clzwp(<2 x i32>) #1

define <2 x i32> @clswp(<2 x i32> %v){
; CHECK-LABEL: clswp:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    clswp $r0 = $r0
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = tail call <2 x i32> @llvm.kvx.clswp(<2 x i32> %v)
  ret <2 x i32> %0
}

declare <2 x i32> @llvm.kvx.clswp(<2 x i32>) #1

define <2 x i32> @cbswp(<2 x i32> %v){
; CHECK-LABEL: cbswp:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    cbswp $r0 = $r0
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = tail call <2 x i32> @llvm.kvx.cbswp(<2 x i32> %v)
  ret <2 x i32> %0
}

declare <2 x i32> @llvm.kvx.cbswp(<2 x i32>) #1

define <4 x i16> @selecthq(<4 x i16> %v1, <4 x i16> %v2, <4 x i16> %c){
; CHECK-LABEL: selecthq:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    cmovehq.nez $r2 ? $r0 = $r1
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = tail call <4 x i16> @llvm.kvx.cmovehq(<4 x i16> %v1, <4 x i16> %v2, <4 x i16> %c, i32 0)
  ret <4 x i16> %0
}

declare <4 x i16> @llvm.kvx.cmovehq(<4 x i16>, <4 x i16>, <4 x i16>, i32) #1

define <8 x i16> @selectho(<8 x i16> %v1, <8 x i16> %v2, <8 x i16> %c){
; CHECK-LABEL: selectho:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    cmovehq.nez $r4 ? $r0 = $r2
; CHECK-NEXT:    cmovehq.nez $r5 ? $r1 = $r3
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = shufflevector <8 x i16> %v1, <8 x i16> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  %1 = shufflevector <8 x i16> %v2, <8 x i16> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  %2 = shufflevector <8 x i16> %c, <8 x i16> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  %3 = tail call <4 x i16> @llvm.kvx.cmovehq(<4 x i16> %0, <4 x i16> %1, <4 x i16> %2, i32 0)
  %4 = shufflevector <8 x i16> %v1, <8 x i16> undef, <4 x i32> <i32 4, i32 5, i32 6, i32 7>
  %5 = shufflevector <8 x i16> %v2, <8 x i16> undef, <4 x i32> <i32 4, i32 5, i32 6, i32 7>
  %6 = shufflevector <8 x i16> %c, <8 x i16> undef, <4 x i32> <i32 4, i32 5, i32 6, i32 7>
  %7 = tail call <4 x i16> @llvm.kvx.cmovehq(<4 x i16> %4, <4 x i16> %5, <4 x i16> %6, i32 0)
  %8 = shufflevector <4 x i16> %3, <4 x i16> %7, <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7>
  ret <8 x i16> %8
}

define <16 x i16> @selecthx(<16 x i16> %v1, <16 x i16> %v2, <16 x i16> %c){
; CHECK-LABEL: selecthx:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    cmovehq.nez $r8 ? $r0 = $r4
; CHECK-NEXT:    cmovehq.nez $r9 ? $r1 = $r5
; CHECK-NEXT:    ;;
; CHECK-NEXT:    cmovehq.nez $r10 ? $r2 = $r6
; CHECK-NEXT:    cmovehq.nez $r11 ? $r3 = $r7
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = shufflevector <16 x i16> %v1, <16 x i16> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  %1 = shufflevector <16 x i16> %v2, <16 x i16> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  %2 = shufflevector <16 x i16> %c, <16 x i16> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  %3 = tail call <4 x i16> @llvm.kvx.cmovehq(<4 x i16> %0, <4 x i16> %1, <4 x i16> %2, i32 0)
  %4 = shufflevector <16 x i16> %v1, <16 x i16> undef, <4 x i32> <i32 4, i32 5, i32 6, i32 7>
  %5 = shufflevector <16 x i16> %v2, <16 x i16> undef, <4 x i32> <i32 4, i32 5, i32 6, i32 7>
  %6 = shufflevector <16 x i16> %c, <16 x i16> undef, <4 x i32> <i32 4, i32 5, i32 6, i32 7>
  %7 = tail call <4 x i16> @llvm.kvx.cmovehq(<4 x i16> %4, <4 x i16> %5, <4 x i16> %6, i32 0)
  %8 = shufflevector <4 x i16> %3, <4 x i16> %7, <16 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef>
  %9 = shufflevector <16 x i16> %v1, <16 x i16> undef, <4 x i32> <i32 8, i32 9, i32 10, i32 11>
  %10 = shufflevector <16 x i16> %v2, <16 x i16> undef, <4 x i32> <i32 8, i32 9, i32 10, i32 11>
  %11 = shufflevector <16 x i16> %c, <16 x i16> undef, <4 x i32> <i32 8, i32 9, i32 10, i32 11>
  %12 = tail call <4 x i16> @llvm.kvx.cmovehq(<4 x i16> %9, <4 x i16> %10, <4 x i16> %11, i32 0)
  %13 = shufflevector <4 x i16> %12, <4 x i16> undef, <16 x i32> <i32 0, i32 1, i32 2, i32 3, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef>
  %14 = shufflevector <16 x i16> %8, <16 x i16> %13, <16 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 16, i32 17, i32 18, i32 19, i32 undef, i32 undef, i32 undef, i32 undef>
  %15 = shufflevector <16 x i16> %v1, <16 x i16> undef, <4 x i32> <i32 12, i32 13, i32 14, i32 15>
  %16 = shufflevector <16 x i16> %v2, <16 x i16> undef, <4 x i32> <i32 12, i32 13, i32 14, i32 15>
  %17 = shufflevector <16 x i16> %c, <16 x i16> undef, <4 x i32> <i32 12, i32 13, i32 14, i32 15>
  %18 = tail call <4 x i16> @llvm.kvx.cmovehq(<4 x i16> %15, <4 x i16> %16, <4 x i16> %17, i32 0)
  %19 = shufflevector <4 x i16> %18, <4 x i16> undef, <16 x i32> <i32 0, i32 1, i32 2, i32 3, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef>
  %20 = shufflevector <16 x i16> %14, <16 x i16> %19, <16 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7, i32 8, i32 9, i32 10, i32 11, i32 16, i32 17, i32 18, i32 19>
  ret <16 x i16> %20
}

define <2 x i32> @selectwp(<2 x i32> %v1, <2 x i32> %v2, <2 x i32> %c){
; CHECK-LABEL: selectwp:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    cmovewp.nez $r2 ? $r0 = $r1
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = tail call <2 x i32> @llvm.kvx.cmovewp(<2 x i32> %v1, <2 x i32> %v2, <2 x i32> %c, i32 0)
  ret <2 x i32> %0
}

declare <2 x i32> @llvm.kvx.cmovewp(<2 x i32>, <2 x i32>, <2 x i32>, i32) #1

define <4 x i32> @selectwq(<4 x i32> %v1, <4 x i32> %v2, <4 x i32> %c){
; CHECK-LABEL: selectwq:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    cmovewp.nez $r4 ? $r0 = $r2
; CHECK-NEXT:    cmovewp.nez $r5 ? $r1 = $r3
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = shufflevector <4 x i32> %v1, <4 x i32> undef, <2 x i32> <i32 0, i32 1>
  %1 = shufflevector <4 x i32> %v2, <4 x i32> undef, <2 x i32> <i32 0, i32 1>
  %2 = shufflevector <4 x i32> %c, <4 x i32> undef, <2 x i32> <i32 0, i32 1>
  %3 = tail call <2 x i32> @llvm.kvx.cmovewp(<2 x i32> %0, <2 x i32> %1, <2 x i32> %2, i32 0)
  %4 = shufflevector <4 x i32> %v1, <4 x i32> undef, <2 x i32> <i32 2, i32 3>
  %5 = shufflevector <4 x i32> %v2, <4 x i32> undef, <2 x i32> <i32 2, i32 3>
  %6 = shufflevector <4 x i32> %c, <4 x i32> undef, <2 x i32> <i32 2, i32 3>
  %7 = tail call <2 x i32> @llvm.kvx.cmovewp(<2 x i32> %4, <2 x i32> %5, <2 x i32> %6, i32 0)
  %8 = shufflevector <2 x i32> %3, <2 x i32> %7, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  ret <4 x i32> %8
}

define <8 x i32> @selectwo(<8 x i32> %v1, <8 x i32> %v2, <8 x i32> %c){
; CHECK-LABEL: selectwo:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    cmovewp.nez $r8 ? $r0 = $r4
; CHECK-NEXT:    cmovewp.nez $r9 ? $r1 = $r5
; CHECK-NEXT:    ;;
; CHECK-NEXT:    cmovewp.nez $r10 ? $r2 = $r6
; CHECK-NEXT:    cmovewp.nez $r11 ? $r3 = $r7
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = shufflevector <8 x i32> %v1, <8 x i32> undef, <2 x i32> <i32 0, i32 1>
  %1 = shufflevector <8 x i32> %v2, <8 x i32> undef, <2 x i32> <i32 0, i32 1>
  %2 = shufflevector <8 x i32> %c, <8 x i32> undef, <2 x i32> <i32 0, i32 1>
  %3 = tail call <2 x i32> @llvm.kvx.cmovewp(<2 x i32> %0, <2 x i32> %1, <2 x i32> %2, i32 0)
  %4 = shufflevector <8 x i32> %v1, <8 x i32> undef, <2 x i32> <i32 2, i32 3>
  %5 = shufflevector <8 x i32> %v2, <8 x i32> undef, <2 x i32> <i32 2, i32 3>
  %6 = shufflevector <8 x i32> %c, <8 x i32> undef, <2 x i32> <i32 2, i32 3>
  %7 = tail call <2 x i32> @llvm.kvx.cmovewp(<2 x i32> %4, <2 x i32> %5, <2 x i32> %6, i32 0)
  %8 = shufflevector <2 x i32> %3, <2 x i32> %7, <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 undef, i32 undef, i32 undef, i32 undef>
  %9 = shufflevector <8 x i32> %v1, <8 x i32> undef, <2 x i32> <i32 4, i32 5>
  %10 = shufflevector <8 x i32> %v2, <8 x i32> undef, <2 x i32> <i32 4, i32 5>
  %11 = shufflevector <8 x i32> %c, <8 x i32> undef, <2 x i32> <i32 4, i32 5>
  %12 = tail call <2 x i32> @llvm.kvx.cmovewp(<2 x i32> %9, <2 x i32> %10, <2 x i32> %11, i32 0)
  %13 = shufflevector <2 x i32> %12, <2 x i32> undef, <8 x i32> <i32 0, i32 1, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef>
  %14 = shufflevector <8 x i32> %8, <8 x i32> %13, <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 8, i32 9, i32 undef, i32 undef>
  %15 = shufflevector <8 x i32> %v1, <8 x i32> undef, <2 x i32> <i32 6, i32 7>
  %16 = shufflevector <8 x i32> %v2, <8 x i32> undef, <2 x i32> <i32 6, i32 7>
  %17 = shufflevector <8 x i32> %c, <8 x i32> undef, <2 x i32> <i32 6, i32 7>
  %18 = tail call <2 x i32> @llvm.kvx.cmovewp(<2 x i32> %15, <2 x i32> %16, <2 x i32> %17, i32 0)
  %19 = shufflevector <2 x i32> %18, <2 x i32> undef, <8 x i32> <i32 0, i32 1, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef>
  %20 = shufflevector <8 x i32> %14, <8 x i32> %19, <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 8, i32 9>
  ret <8 x i32> %20
}

define <2 x i64> @selectdp(<2 x i64> %v1, <2 x i64> %v2, <2 x i64> %c){
; CHECK-LABEL: selectdp:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    cmoved.dnez $r4 ? $r0 = $r2
; CHECK-NEXT:    cmoved.dnez $r5 ? $r1 = $r3
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = extractelement <2 x i64> %v1, i64 0
  %1 = extractelement <2 x i64> %v2, i64 0
  %2 = extractelement <2 x i64> %c, i64 0
  %3 = tail call i64 @llvm.kvx.cmoved(i64 %0, i64 %1, i64 %2, i32 0)
  %4 = insertelement <2 x i64> undef, i64 %3, i64 0
  %5 = extractelement <2 x i64> %v1, i64 1
  %6 = extractelement <2 x i64> %v2, i64 1
  %7 = extractelement <2 x i64> %c, i64 1
  %8 = tail call i64 @llvm.kvx.cmoved(i64 %5, i64 %6, i64 %7, i32 0)
  %9 = insertelement <2 x i64> %4, i64 %8, i64 1
  ret <2 x i64> %9
}

declare i64 @llvm.kvx.cmoved(i64, i64, i64, i32) #1

define <4 x i64> @selectdq(<4 x i64> %v1, <4 x i64> %v2, <4 x i64> %c){
; CHECK-LABEL: selectdq:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    cmoved.dnez $r8 ? $r0 = $r4
; CHECK-NEXT:    cmoved.dnez $r9 ? $r1 = $r5
; CHECK-NEXT:    ;;
; CHECK-NEXT:    cmoved.dnez $r10 ? $r2 = $r6
; CHECK-NEXT:    cmoved.dnez $r11 ? $r3 = $r7
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = extractelement <4 x i64> %v1, i64 0
  %1 = extractelement <4 x i64> %v2, i64 0
  %2 = extractelement <4 x i64> %c, i64 0
  %3 = tail call i64 @llvm.kvx.cmoved(i64 %0, i64 %1, i64 %2, i32 0)
  %4 = insertelement <4 x i64> undef, i64 %3, i64 0
  %5 = extractelement <4 x i64> %v1, i64 1
  %6 = extractelement <4 x i64> %v2, i64 1
  %7 = extractelement <4 x i64> %c, i64 1
  %8 = tail call i64 @llvm.kvx.cmoved(i64 %5, i64 %6, i64 %7, i32 0)
  %9 = insertelement <4 x i64> %4, i64 %8, i64 1
  %10 = extractelement <4 x i64> %v1, i64 2
  %11 = extractelement <4 x i64> %v2, i64 2
  %12 = extractelement <4 x i64> %c, i64 2
  %13 = tail call i64 @llvm.kvx.cmoved(i64 %10, i64 %11, i64 %12, i32 0)
  %14 = insertelement <4 x i64> %9, i64 %13, i64 2
  %15 = extractelement <4 x i64> %v1, i64 3
  %16 = extractelement <4 x i64> %v2, i64 3
  %17 = extractelement <4 x i64> %c, i64 3
  %18 = tail call i64 @llvm.kvx.cmoved(i64 %15, i64 %16, i64 %17, i32 0)
  %19 = insertelement <4 x i64> %14, i64 %18, i64 3
  ret <4 x i64> %19
}

define <2 x float> @selectfwp(<2 x float> %v1, <2 x float> %v2, <2 x i32> %c){
; CHECK-LABEL: selectfwp:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    cmovewp.nez $r2 ? $r0 = $r1
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = bitcast <2 x float> %v1 to <2 x i32>
  %1 = bitcast <2 x float> %v2 to <2 x i32>
  %2 = tail call <2 x i32> @llvm.kvx.cmovewp(<2 x i32> %0, <2 x i32> %1, <2 x i32> %c, i32 0)
  %3 = bitcast <2 x i32> %2 to <2 x float>
  ret <2 x float> %3
}

define <4 x float> @selectfwq(<4 x float> %v1, <4 x float> %v2, <4 x i32> %c){
; CHECK-LABEL: selectfwq:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    cmovewp.nez $r4 ? $r0 = $r2
; CHECK-NEXT:    cmovewp.nez $r5 ? $r1 = $r3
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = shufflevector <4 x float> %v1, <4 x float> undef, <2 x i32> <i32 0, i32 1>
  %1 = shufflevector <4 x float> %v2, <4 x float> undef, <2 x i32> <i32 0, i32 1>
  %2 = bitcast <2 x float> %0 to <2 x i32>
  %3 = bitcast <2 x float> %1 to <2 x i32>
  %4 = shufflevector <4 x i32> %c, <4 x i32> undef, <2 x i32> <i32 0, i32 1>
  %5 = tail call <2 x i32> @llvm.kvx.cmovewp(<2 x i32> %2, <2 x i32> %3, <2 x i32> %4, i32 0)
  %6 = bitcast <2 x i32> %5 to <2 x float>
  %7 = shufflevector <4 x float> %v1, <4 x float> undef, <2 x i32> <i32 2, i32 3>
  %8 = shufflevector <4 x float> %v2, <4 x float> undef, <2 x i32> <i32 2, i32 3>
  %9 = bitcast <2 x float> %7 to <2 x i32>
  %10 = bitcast <2 x float> %8 to <2 x i32>
  %11 = shufflevector <4 x i32> %c, <4 x i32> undef, <2 x i32> <i32 2, i32 3>
  %12 = tail call <2 x i32> @llvm.kvx.cmovewp(<2 x i32> %9, <2 x i32> %10, <2 x i32> %11, i32 0)
  %13 = bitcast <2 x i32> %12 to <2 x float>
  %14 = shufflevector <2 x float> %6, <2 x float> %13, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  ret <4 x float> %14
}

define <8 x float> @selectfwo(<8 x float> %v1, <8 x float> %v2, <8 x i32> %c){
; CHECK-LABEL: selectfwo:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    cmovewp.nez $r8 ? $r0 = $r4
; CHECK-NEXT:    cmovewp.nez $r9 ? $r1 = $r5
; CHECK-NEXT:    ;;
; CHECK-NEXT:    cmovewp.nez $r10 ? $r2 = $r6
; CHECK-NEXT:    cmovewp.nez $r11 ? $r3 = $r7
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = shufflevector <8 x float> %v1, <8 x float> undef, <2 x i32> <i32 0, i32 1>
  %1 = shufflevector <8 x float> %v2, <8 x float> undef, <2 x i32> <i32 0, i32 1>
  %2 = bitcast <2 x float> %0 to <2 x i32>
  %3 = bitcast <2 x float> %1 to <2 x i32>
  %4 = shufflevector <8 x i32> %c, <8 x i32> undef, <2 x i32> <i32 0, i32 1>
  %5 = tail call <2 x i32> @llvm.kvx.cmovewp(<2 x i32> %2, <2 x i32> %3, <2 x i32> %4, i32 0)
  %6 = bitcast <2 x i32> %5 to <2 x float>
  %7 = shufflevector <8 x float> %v1, <8 x float> undef, <2 x i32> <i32 2, i32 3>
  %8 = shufflevector <8 x float> %v2, <8 x float> undef, <2 x i32> <i32 2, i32 3>
  %9 = bitcast <2 x float> %7 to <2 x i32>
  %10 = bitcast <2 x float> %8 to <2 x i32>
  %11 = shufflevector <8 x i32> %c, <8 x i32> undef, <2 x i32> <i32 2, i32 3>
  %12 = tail call <2 x i32> @llvm.kvx.cmovewp(<2 x i32> %9, <2 x i32> %10, <2 x i32> %11, i32 0)
  %13 = bitcast <2 x i32> %12 to <2 x float>
  %14 = shufflevector <2 x float> %6, <2 x float> %13, <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 undef, i32 undef, i32 undef, i32 undef>
  %15 = shufflevector <8 x float> %v1, <8 x float> undef, <2 x i32> <i32 4, i32 5>
  %16 = shufflevector <8 x float> %v2, <8 x float> undef, <2 x i32> <i32 4, i32 5>
  %17 = bitcast <2 x float> %15 to <2 x i32>
  %18 = bitcast <2 x float> %16 to <2 x i32>
  %19 = shufflevector <8 x i32> %c, <8 x i32> undef, <2 x i32> <i32 4, i32 5>
  %20 = tail call <2 x i32> @llvm.kvx.cmovewp(<2 x i32> %17, <2 x i32> %18, <2 x i32> %19, i32 0)
  %21 = bitcast <2 x i32> %20 to <2 x float>
  %22 = shufflevector <2 x float> %21, <2 x float> undef, <8 x i32> <i32 0, i32 1, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef>
  %23 = shufflevector <8 x float> %14, <8 x float> %22, <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 8, i32 9, i32 undef, i32 undef>
  %24 = shufflevector <8 x float> %v1, <8 x float> undef, <2 x i32> <i32 6, i32 7>
  %25 = shufflevector <8 x float> %v2, <8 x float> undef, <2 x i32> <i32 6, i32 7>
  %26 = bitcast <2 x float> %24 to <2 x i32>
  %27 = bitcast <2 x float> %25 to <2 x i32>
  %28 = shufflevector <8 x i32> %c, <8 x i32> undef, <2 x i32> <i32 6, i32 7>
  %29 = tail call <2 x i32> @llvm.kvx.cmovewp(<2 x i32> %26, <2 x i32> %27, <2 x i32> %28, i32 0)
  %30 = bitcast <2 x i32> %29 to <2 x float>
  %31 = shufflevector <2 x float> %30, <2 x float> undef, <8 x i32> <i32 0, i32 1, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef>
  %32 = shufflevector <8 x float> %23, <8 x float> %31, <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 8, i32 9>
  ret <8 x float> %32
}

define <2 x double> @selectfdp(<2 x double> %v1, <2 x double> %v2, <2 x i64> %c){
; CHECK-LABEL: selectfdp:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    cmoved.dnez $r4 ? $r0 = $r2
; CHECK-NEXT:    cmoved.dnez $r5 ? $r1 = $r3
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %bc = bitcast <2 x double> %v1 to <2 x i64>
  %0 = extractelement <2 x i64> %bc, i64 0
  %bc1 = bitcast <2 x double> %v2 to <2 x i64>
  %1 = extractelement <2 x i64> %bc1, i64 0
  %2 = extractelement <2 x i64> %c, i64 0
  %3 = tail call i64 @llvm.kvx.cmoved(i64 %0, i64 %1, i64 %2, i32 0)
  %4 = bitcast i64 %3 to double
  %5 = insertelement <2 x double> undef, double %4, i64 0
  %6 = extractelement <2 x i64> %bc, i64 1
  %7 = extractelement <2 x i64> %bc1, i64 1
  %8 = extractelement <2 x i64> %c, i64 1
  %9 = tail call i64 @llvm.kvx.cmoved(i64 %6, i64 %7, i64 %8, i32 0)
  %10 = bitcast i64 %9 to double
  %11 = insertelement <2 x double> %5, double %10, i64 1
  ret <2 x double> %11
}

define <4 x double> @selectfdq(<4 x double> %v1, <4 x double> %v2, <4 x i64> %c){
; CHECK-LABEL: selectfdq:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    cmoved.dnez $r8 ? $r0 = $r4
; CHECK-NEXT:    cmoved.dnez $r9 ? $r1 = $r5
; CHECK-NEXT:    ;;
; CHECK-NEXT:    cmoved.dnez $r10 ? $r2 = $r6
; CHECK-NEXT:    cmoved.dnez $r11 ? $r3 = $r7
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %bc = bitcast <4 x double> %v1 to <4 x i64>
  %0 = extractelement <4 x i64> %bc, i64 0
  %bc1 = bitcast <4 x double> %v2 to <4 x i64>
  %1 = extractelement <4 x i64> %bc1, i64 0
  %2 = extractelement <4 x i64> %c, i64 0
  %3 = tail call i64 @llvm.kvx.cmoved(i64 %0, i64 %1, i64 %2, i32 0)
  %4 = bitcast i64 %3 to double
  %5 = insertelement <4 x double> undef, double %4, i64 0
  %6 = extractelement <4 x i64> %bc, i64 1
  %7 = extractelement <4 x i64> %bc1, i64 1
  %8 = extractelement <4 x i64> %c, i64 1
  %9 = tail call i64 @llvm.kvx.cmoved(i64 %6, i64 %7, i64 %8, i32 0)
  %10 = bitcast i64 %9 to double
  %11 = insertelement <4 x double> %5, double %10, i64 1
  %12 = extractelement <4 x i64> %bc, i64 2
  %13 = extractelement <4 x i64> %bc1, i64 2
  %14 = extractelement <4 x i64> %c, i64 2
  %15 = tail call i64 @llvm.kvx.cmoved(i64 %12, i64 %13, i64 %14, i32 0)
  %16 = bitcast i64 %15 to double
  %17 = insertelement <4 x double> %11, double %16, i64 2
  %18 = extractelement <4 x i64> %bc, i64 3
  %19 = extractelement <4 x i64> %bc1, i64 3
  %20 = extractelement <4 x i64> %c, i64 3
  %21 = tail call i64 @llvm.kvx.cmoved(i64 %18, i64 %19, i64 %20, i32 0)
  %22 = bitcast i64 %21 to double
  %23 = insertelement <4 x double> %17, double %22, i64 3
  ret <4 x double> %23
}

define <2 x float> @fabswp(<2 x float> %v){
; CHECK-LABEL: fabswp:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    fabswp $r0 = $r0
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = tail call <2 x float> @llvm.kvx.fabswp(<2 x float> %v)
  ret <2 x float> %0
}

declare <2 x float> @llvm.kvx.fabswp(<2 x float>) #1

define <4 x float> @fabswq(<4 x float> %v){
; CHECK-LABEL: fabswq:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    fabswp $r0 = $r0
; CHECK-NEXT:    fabswp $r1 = $r1
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = shufflevector <4 x float> %v, <4 x float> undef, <2 x i32> <i32 0, i32 1>
  %1 = tail call <2 x float> @llvm.kvx.fabswp(<2 x float> %0)
  %2 = shufflevector <4 x float> %v, <4 x float> undef, <2 x i32> <i32 2, i32 3>
  %3 = tail call <2 x float> @llvm.kvx.fabswp(<2 x float> %2)
  %4 = shufflevector <2 x float> %1, <2 x float> %3, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  ret <4 x float> %4
}

define <8 x float> @fabswo(<8 x float> %v){
; CHECK-LABEL: fabswo:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    fabswp $r0 = $r0
; CHECK-NEXT:    fabswp $r1 = $r1
; CHECK-NEXT:    ;;
; CHECK-NEXT:    fabswp $r2 = $r2
; CHECK-NEXT:    fabswp $r3 = $r3
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = shufflevector <8 x float> %v, <8 x float> undef, <2 x i32> <i32 0, i32 1>
  %1 = tail call <2 x float> @llvm.kvx.fabswp(<2 x float> %0)
  %2 = shufflevector <8 x float> %v, <8 x float> undef, <2 x i32> <i32 2, i32 3>
  %3 = tail call <2 x float> @llvm.kvx.fabswp(<2 x float> %2)
  %4 = shufflevector <2 x float> %1, <2 x float> %3, <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 undef, i32 undef, i32 undef, i32 undef>
  %5 = shufflevector <8 x float> %v, <8 x float> undef, <2 x i32> <i32 4, i32 5>
  %6 = tail call <2 x float> @llvm.kvx.fabswp(<2 x float> %5)
  %7 = shufflevector <2 x float> %6, <2 x float> undef, <8 x i32> <i32 0, i32 1, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef>
  %8 = shufflevector <8 x float> %4, <8 x float> %7, <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 8, i32 9, i32 undef, i32 undef>
  %9 = shufflevector <8 x float> %v, <8 x float> undef, <2 x i32> <i32 6, i32 7>
  %10 = tail call <2 x float> @llvm.kvx.fabswp(<2 x float> %9)
  %11 = shufflevector <2 x float> %10, <2 x float> undef, <8 x i32> <i32 0, i32 1, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef>
  %12 = shufflevector <8 x float> %8, <8 x float> %11, <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 8, i32 9>
  ret <8 x float> %12
}

define <2 x double> @fabsdp(<2 x double> %v){
; CHECK-LABEL: fabsdp:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    fabsd $r0 = $r0
; CHECK-NEXT:    fabsd $r1 = $r1
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = extractelement <2 x double> %v, i64 0
  %1 = tail call double @llvm.kvx.fabsd(double %0)
  %2 = insertelement <2 x double> undef, double %1, i64 0
  %3 = extractelement <2 x double> %v, i64 1
  %4 = tail call double @llvm.kvx.fabsd(double %3)
  %5 = insertelement <2 x double> %2, double %4, i64 1
  ret <2 x double> %5
}

declare double @llvm.kvx.fabsd(double) #1

define <4 x double> @fabsdq(<4 x double> %v){
; CHECK-LABEL: fabsdq:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    fabsd $r0 = $r0
; CHECK-NEXT:    fabsd $r1 = $r1
; CHECK-NEXT:    ;;
; CHECK-NEXT:    fabsd $r2 = $r2
; CHECK-NEXT:    fabsd $r3 = $r3
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = extractelement <4 x double> %v, i64 0
  %1 = tail call double @llvm.kvx.fabsd(double %0)
  %2 = insertelement <4 x double> undef, double %1, i64 0
  %3 = extractelement <4 x double> %v, i64 1
  %4 = tail call double @llvm.kvx.fabsd(double %3)
  %5 = insertelement <4 x double> %2, double %4, i64 1
  %6 = extractelement <4 x double> %v, i64 2
  %7 = tail call double @llvm.kvx.fabsd(double %6)
  %8 = insertelement <4 x double> %5, double %7, i64 2
  %9 = extractelement <4 x double> %v, i64 3
  %10 = tail call double @llvm.kvx.fabsd(double %9)
  %11 = insertelement <4 x double> %8, double %10, i64 3
  ret <4 x double> %11
}

define <2 x float> @fnegwp(<2 x float> %v){
; CHECK-LABEL: fnegwp:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    fnegwp $r0 = $r0
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = tail call <2 x float> @llvm.kvx.fnegwp(<2 x float> %v)
  ret <2 x float> %0
}

declare <2 x float> @llvm.kvx.fnegwp(<2 x float>) #1

define <4 x float> @fnegwq(<4 x float> %v){
; CHECK-LABEL: fnegwq:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    fnegwp $r0 = $r0
; CHECK-NEXT:    fnegwp $r1 = $r1
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = shufflevector <4 x float> %v, <4 x float> undef, <2 x i32> <i32 0, i32 1>
  %1 = tail call <2 x float> @llvm.kvx.fnegwp(<2 x float> %0)
  %2 = shufflevector <4 x float> %v, <4 x float> undef, <2 x i32> <i32 2, i32 3>
  %3 = tail call <2 x float> @llvm.kvx.fnegwp(<2 x float> %2)
  %4 = shufflevector <2 x float> %1, <2 x float> %3, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  ret <4 x float> %4
}

define <8 x float> @fnegwo(<8 x float> %v){
; CHECK-LABEL: fnegwo:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    fnegwp $r0 = $r0
; CHECK-NEXT:    fnegwp $r1 = $r1
; CHECK-NEXT:    ;;
; CHECK-NEXT:    fnegwp $r2 = $r2
; CHECK-NEXT:    fnegwp $r3 = $r3
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = shufflevector <8 x float> %v, <8 x float> undef, <2 x i32> <i32 0, i32 1>
  %1 = tail call <2 x float> @llvm.kvx.fnegwp(<2 x float> %0)
  %2 = shufflevector <8 x float> %v, <8 x float> undef, <2 x i32> <i32 2, i32 3>
  %3 = tail call <2 x float> @llvm.kvx.fnegwp(<2 x float> %2)
  %4 = shufflevector <2 x float> %1, <2 x float> %3, <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 undef, i32 undef, i32 undef, i32 undef>
  %5 = shufflevector <8 x float> %v, <8 x float> undef, <2 x i32> <i32 4, i32 5>
  %6 = tail call <2 x float> @llvm.kvx.fnegwp(<2 x float> %5)
  %7 = shufflevector <2 x float> %6, <2 x float> undef, <8 x i32> <i32 0, i32 1, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef>
  %8 = shufflevector <8 x float> %4, <8 x float> %7, <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 8, i32 9, i32 undef, i32 undef>
  %9 = shufflevector <8 x float> %v, <8 x float> undef, <2 x i32> <i32 6, i32 7>
  %10 = tail call <2 x float> @llvm.kvx.fnegwp(<2 x float> %9)
  %11 = shufflevector <2 x float> %10, <2 x float> undef, <8 x i32> <i32 0, i32 1, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef>
  %12 = shufflevector <8 x float> %8, <8 x float> %11, <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 8, i32 9>
  ret <8 x float> %12
}

define <2 x double> @fnegdp(<2 x double> %v){
; CHECK-LABEL: fnegdp:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    fnegd $r0 = $r0
; CHECK-NEXT:    fnegd $r1 = $r1
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = extractelement <2 x double> %v, i64 0
  %1 = tail call double @llvm.kvx.fnegd(double %0)
  %2 = insertelement <2 x double> undef, double %1, i64 0
  %3 = extractelement <2 x double> %v, i64 1
  %4 = tail call double @llvm.kvx.fnegd(double %3)
  %5 = insertelement <2 x double> %2, double %4, i64 1
  ret <2 x double> %5
}

declare double @llvm.kvx.fnegd(double) #1

define <4 x double> @fnegdq(<4 x double> %v){
; CHECK-LABEL: fnegdq:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    fnegd $r0 = $r0
; CHECK-NEXT:    fnegd $r1 = $r1
; CHECK-NEXT:    ;;
; CHECK-NEXT:    fnegd $r2 = $r2
; CHECK-NEXT:    fnegd $r3 = $r3
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = extractelement <4 x double> %v, i64 0
  %1 = tail call double @llvm.kvx.fnegd(double %0)
  %2 = insertelement <4 x double> undef, double %1, i64 0
  %3 = extractelement <4 x double> %v, i64 1
  %4 = tail call double @llvm.kvx.fnegd(double %3)
  %5 = insertelement <4 x double> %2, double %4, i64 1
  %6 = extractelement <4 x double> %v, i64 2
  %7 = tail call double @llvm.kvx.fnegd(double %6)
  %8 = insertelement <4 x double> %5, double %7, i64 2
  %9 = extractelement <4 x double> %v, i64 3
  %10 = tail call double @llvm.kvx.fnegd(double %9)
  %11 = insertelement <4 x double> %8, double %10, i64 3
  ret <4 x double> %11
}

define <2 x float> @fmaxwp(<2 x float> %v1, <2 x float> %v2){
; CHECK-LABEL: fmaxwp:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    fmaxwp $r0 = $r0, $r1
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = tail call <2 x float> @llvm.kvx.fmaxwp(<2 x float> %v1, <2 x float> %v2)
  ret <2 x float> %0
}

declare <2 x float> @llvm.kvx.fmaxwp(<2 x float>, <2 x float>) #1

define <4 x float> @fmaxwq(<4 x float> %v1, <4 x float> %v2){
; CHECK-LABEL: fmaxwq:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    fmaxwp $r0 = $r0, $r0
; CHECK-NEXT:    fmaxwp $r1 = $r1, $r1
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = shufflevector <4 x float> %v1, <4 x float> undef, <2 x i32> <i32 0, i32 1>
  %1 = tail call <2 x float> @llvm.kvx.fmaxwp(<2 x float> %0, <2 x float> %0)
  %2 = shufflevector <4 x float> %v1, <4 x float> undef, <2 x i32> <i32 2, i32 3>
  %3 = tail call <2 x float> @llvm.kvx.fmaxwp(<2 x float> %2, <2 x float> %2)
  %4 = shufflevector <2 x float> %1, <2 x float> %3, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  ret <4 x float> %4
}

define <8 x float> @fmaxwo(<8 x float> %v1, <8 x float> %v2){
; CHECK-LABEL: fmaxwo:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    fmaxwp $r0 = $r0, $r4
; CHECK-NEXT:    fmaxwp $r1 = $r1, $r5
; CHECK-NEXT:    ;;
; CHECK-NEXT:    fmaxwp $r2 = $r2, $r6
; CHECK-NEXT:    fmaxwp $r3 = $r3, $r7
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = shufflevector <8 x float> %v1, <8 x float> undef, <2 x i32> <i32 0, i32 1>
  %1 = shufflevector <8 x float> %v2, <8 x float> undef, <2 x i32> <i32 0, i32 1>
  %2 = tail call <2 x float> @llvm.kvx.fmaxwp(<2 x float> %0, <2 x float> %1)
  %3 = shufflevector <8 x float> %v1, <8 x float> undef, <2 x i32> <i32 2, i32 3>
  %4 = shufflevector <8 x float> %v2, <8 x float> undef, <2 x i32> <i32 2, i32 3>
  %5 = tail call <2 x float> @llvm.kvx.fmaxwp(<2 x float> %3, <2 x float> %4)
  %6 = shufflevector <2 x float> %2, <2 x float> %5, <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 undef, i32 undef, i32 undef, i32 undef>
  %7 = shufflevector <8 x float> %v1, <8 x float> undef, <2 x i32> <i32 4, i32 5>
  %8 = shufflevector <8 x float> %v2, <8 x float> undef, <2 x i32> <i32 4, i32 5>
  %9 = tail call <2 x float> @llvm.kvx.fmaxwp(<2 x float> %7, <2 x float> %8)
  %10 = shufflevector <2 x float> %9, <2 x float> undef, <8 x i32> <i32 0, i32 1, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef>
  %11 = shufflevector <8 x float> %6, <8 x float> %10, <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 8, i32 9, i32 undef, i32 undef>
  %12 = shufflevector <8 x float> %v1, <8 x float> undef, <2 x i32> <i32 6, i32 7>
  %13 = shufflevector <8 x float> %v2, <8 x float> undef, <2 x i32> <i32 6, i32 7>
  %14 = tail call <2 x float> @llvm.kvx.fmaxwp(<2 x float> %12, <2 x float> %13)
  %15 = shufflevector <2 x float> %14, <2 x float> undef, <8 x i32> <i32 0, i32 1, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef>
  %16 = shufflevector <8 x float> %11, <8 x float> %15, <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 8, i32 9>
  ret <8 x float> %16
}

define <2 x double> @fmaxdp(<2 x double> %v1, <2 x double> %v2){
; CHECK-LABEL: fmaxdp:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    fmaxd $r0 = $r0, $r2
; CHECK-NEXT:    fmaxd $r1 = $r1, $r3
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = extractelement <2 x double> %v1, i64 0
  %1 = extractelement <2 x double> %v2, i64 0
  %2 = tail call double @llvm.kvx.fmaxd(double %0, double %1)
  %3 = insertelement <2 x double> undef, double %2, i64 0
  %4 = extractelement <2 x double> %v1, i64 1
  %5 = extractelement <2 x double> %v2, i64 1
  %6 = tail call double @llvm.kvx.fmaxd(double %4, double %5)
  %7 = insertelement <2 x double> %3, double %6, i64 1
  ret <2 x double> %7
}

declare double @llvm.kvx.fmaxd(double, double) #1

define <4 x double> @fmaxdq(<4 x double> %v1, <4 x double> %v2){
; CHECK-LABEL: fmaxdq:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    fmaxd $r0 = $r0, $r4
; CHECK-NEXT:    fmaxd $r1 = $r1, $r5
; CHECK-NEXT:    ;;
; CHECK-NEXT:    fmaxd $r2 = $r2, $r6
; CHECK-NEXT:    fmaxd $r3 = $r3, $r7
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = extractelement <4 x double> %v1, i64 0
  %1 = extractelement <4 x double> %v2, i64 0
  %2 = tail call double @llvm.kvx.fmaxd(double %0, double %1)
  %3 = insertelement <4 x double> undef, double %2, i64 0
  %4 = extractelement <4 x double> %v1, i64 1
  %5 = extractelement <4 x double> %v2, i64 1
  %6 = tail call double @llvm.kvx.fmaxd(double %4, double %5)
  %7 = insertelement <4 x double> %3, double %6, i64 1
  %8 = extractelement <4 x double> %v1, i64 2
  %9 = extractelement <4 x double> %v2, i64 2
  %10 = tail call double @llvm.kvx.fmaxd(double %8, double %9)
  %11 = insertelement <4 x double> %7, double %10, i64 2
  %12 = extractelement <4 x double> %v1, i64 3
  %13 = extractelement <4 x double> %v2, i64 3
  %14 = tail call double @llvm.kvx.fmaxd(double %12, double %13)
  %15 = insertelement <4 x double> %11, double %14, i64 3
  ret <4 x double> %15
}

define <2 x float> @fminwp(<2 x float> %v1, <2 x float> %v2){
; CHECK-LABEL: fminwp:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    fminwp $r0 = $r0, $r1
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = tail call <2 x float> @llvm.kvx.fminwp(<2 x float> %v1, <2 x float> %v2)
  ret <2 x float> %0
}

declare <2 x float> @llvm.kvx.fminwp(<2 x float>, <2 x float>) #1

define <4 x float> @fminwq(<4 x float> %v1, <4 x float> %v2){
; CHECK-LABEL: fminwq:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    fminwp $r0 = $r0, $r2
; CHECK-NEXT:    fminwp $r1 = $r1, $r3
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = shufflevector <4 x float> %v1, <4 x float> undef, <2 x i32> <i32 0, i32 1>
  %1 = shufflevector <4 x float> %v2, <4 x float> undef, <2 x i32> <i32 0, i32 1>
  %2 = tail call <2 x float> @llvm.kvx.fminwp(<2 x float> %0, <2 x float> %1)
  %3 = shufflevector <4 x float> %v1, <4 x float> undef, <2 x i32> <i32 2, i32 3>
  %4 = shufflevector <4 x float> %v2, <4 x float> undef, <2 x i32> <i32 2, i32 3>
  %5 = tail call <2 x float> @llvm.kvx.fminwp(<2 x float> %3, <2 x float> %4)
  %6 = shufflevector <2 x float> %2, <2 x float> %5, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  ret <4 x float> %6
}

define <8 x float> @fminwo(<8 x float> %v1, <8 x float> %v2){
; CHECK-LABEL: fminwo:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    fminwp $r0 = $r0, $r4
; CHECK-NEXT:    fminwp $r1 = $r1, $r5
; CHECK-NEXT:    ;;
; CHECK-NEXT:    fminwp $r2 = $r2, $r6
; CHECK-NEXT:    fminwp $r3 = $r3, $r7
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = shufflevector <8 x float> %v1, <8 x float> undef, <2 x i32> <i32 0, i32 1>
  %1 = shufflevector <8 x float> %v2, <8 x float> undef, <2 x i32> <i32 0, i32 1>
  %2 = tail call <2 x float> @llvm.kvx.fminwp(<2 x float> %0, <2 x float> %1)
  %3 = shufflevector <8 x float> %v1, <8 x float> undef, <2 x i32> <i32 2, i32 3>
  %4 = shufflevector <8 x float> %v2, <8 x float> undef, <2 x i32> <i32 2, i32 3>
  %5 = tail call <2 x float> @llvm.kvx.fminwp(<2 x float> %3, <2 x float> %4)
  %6 = shufflevector <2 x float> %2, <2 x float> %5, <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 undef, i32 undef, i32 undef, i32 undef>
  %7 = shufflevector <8 x float> %v1, <8 x float> undef, <2 x i32> <i32 4, i32 5>
  %8 = shufflevector <8 x float> %v2, <8 x float> undef, <2 x i32> <i32 4, i32 5>
  %9 = tail call <2 x float> @llvm.kvx.fminwp(<2 x float> %7, <2 x float> %8)
  %10 = shufflevector <2 x float> %9, <2 x float> undef, <8 x i32> <i32 0, i32 1, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef>
  %11 = shufflevector <8 x float> %6, <8 x float> %10, <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 8, i32 9, i32 undef, i32 undef>
  %12 = shufflevector <8 x float> %v1, <8 x float> undef, <2 x i32> <i32 6, i32 7>
  %13 = shufflevector <8 x float> %v2, <8 x float> undef, <2 x i32> <i32 6, i32 7>
  %14 = tail call <2 x float> @llvm.kvx.fminwp(<2 x float> %12, <2 x float> %13)
  %15 = shufflevector <2 x float> %14, <2 x float> undef, <8 x i32> <i32 0, i32 1, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef>
  %16 = shufflevector <8 x float> %11, <8 x float> %15, <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 8, i32 9>
  ret <8 x float> %16
}

define <2 x double> @fmindp(<2 x double> %v1, <2 x double> %v2){
; CHECK-LABEL: fmindp:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    fmind $r0 = $r0, $r2
; CHECK-NEXT:    fmind $r1 = $r1, $r3
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = extractelement <2 x double> %v1, i64 0
  %1 = extractelement <2 x double> %v2, i64 0
  %2 = tail call double @llvm.kvx.fmind(double %0, double %1)
  %3 = insertelement <2 x double> undef, double %2, i64 0
  %4 = extractelement <2 x double> %v1, i64 1
  %5 = extractelement <2 x double> %v2, i64 1
  %6 = tail call double @llvm.kvx.fmind(double %4, double %5)
  %7 = insertelement <2 x double> %3, double %6, i64 1
  ret <2 x double> %7
}

declare double @llvm.kvx.fmind(double, double) #1

define <4 x double> @fmindq(<4 x double> %v1, <4 x double> %v2){
; CHECK-LABEL: fmindq:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    fmind $r0 = $r0, $r4
; CHECK-NEXT:    fmind $r1 = $r1, $r5
; CHECK-NEXT:    ;;
; CHECK-NEXT:    fmind $r2 = $r2, $r6
; CHECK-NEXT:    fmind $r3 = $r3, $r7
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = extractelement <4 x double> %v1, i64 0
  %1 = extractelement <4 x double> %v2, i64 0
  %2 = tail call double @llvm.kvx.fmind(double %0, double %1)
  %3 = insertelement <4 x double> undef, double %2, i64 0
  %4 = extractelement <4 x double> %v1, i64 1
  %5 = extractelement <4 x double> %v2, i64 1
  %6 = tail call double @llvm.kvx.fmind(double %4, double %5)
  %7 = insertelement <4 x double> %3, double %6, i64 1
  %8 = extractelement <4 x double> %v1, i64 2
  %9 = extractelement <4 x double> %v2, i64 2
  %10 = tail call double @llvm.kvx.fmind(double %8, double %9)
  %11 = insertelement <4 x double> %7, double %10, i64 2
  %12 = extractelement <4 x double> %v1, i64 3
  %13 = extractelement <4 x double> %v2, i64 3
  %14 = tail call double @llvm.kvx.fmind(double %12, double %13)
  %15 = insertelement <4 x double> %11, double %14, i64 3
  ret <4 x double> %15
}

define <2 x float> @faddwp(<2 x float> %v1, <2 x float> %v2){
; CHECK-LABEL: faddwp:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    faddwp.rn $r0 = $r0, $r1
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = tail call <2 x float> @llvm.kvx.faddwp(<2 x float> %v1, <2 x float> %v2, i32 0)
  ret <2 x float> %0
}

declare <2 x float> @llvm.kvx.faddwp(<2 x float>, <2 x float>, i32) #1

define <4 x float> @faddwq(<4 x float> %v1, <4 x float> %v2){
; CHECK-LABEL: faddwq:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    faddwq.rn $r0r1 = $r0r1, $r2r3
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = tail call <4 x float> @llvm.kvx.faddwq(<4 x float> %v1, <4 x float> %v2, i32 0)
  ret <4 x float> %0
}

declare <4 x float> @llvm.kvx.faddwq(<4 x float>, <4 x float>, i32) #1

define <8 x float> @faddwo(<8 x float> %v1, <8 x float> %v2){
; CHECK-LABEL: faddwo:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    faddwq.rn $r0r1 = $r0r1, $r4r5
; CHECK-NEXT:    ;;
; CHECK-NEXT:    faddwq.rn $r2r3 = $r2r3, $r6r7
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = shufflevector <8 x float> %v1, <8 x float> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  %1 = shufflevector <8 x float> %v2, <8 x float> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  %2 = tail call <4 x float> @llvm.kvx.faddwq(<4 x float> %0, <4 x float> %1, i32 0)
  %3 = shufflevector <8 x float> %v1, <8 x float> undef, <4 x i32> <i32 4, i32 5, i32 6, i32 7>
  %4 = shufflevector <8 x float> %v2, <8 x float> undef, <4 x i32> <i32 4, i32 5, i32 6, i32 7>
  %5 = tail call <4 x float> @llvm.kvx.faddwq(<4 x float> %3, <4 x float> %4, i32 0)
  %6 = shufflevector <4 x float> %2, <4 x float> %5, <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7>
  ret <8 x float> %6
}

define <2 x double> @fadddp(<2 x double> %v1, <2 x double> %v2){
; CHECK-LABEL: fadddp:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    fadddp.rn $r0r1 = $r0r1, $r2r3
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = tail call <2 x double> @llvm.kvx.fadddp(<2 x double> %v1, <2 x double> %v2, i32 0)
  ret <2 x double> %0
}

declare <2 x double> @llvm.kvx.fadddp(<2 x double>, <2 x double>, i32) #1

define <4 x double> @fadddq(<4 x double> %v1, <4 x double> %v2){
; CHECK-LABEL: fadddq:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    fadddp.rn $r0r1 = $r0r1, $r4r5
; CHECK-NEXT:    ;;
; CHECK-NEXT:    fadddp.rn $r2r3 = $r2r3, $r6r7
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = shufflevector <4 x double> %v1, <4 x double> undef, <2 x i32> <i32 0, i32 1>
  %1 = shufflevector <4 x double> %v2, <4 x double> undef, <2 x i32> <i32 0, i32 1>
  %2 = tail call <2 x double> @llvm.kvx.fadddp(<2 x double> %0, <2 x double> %1, i32 0)
  %3 = shufflevector <4 x double> %v1, <4 x double> undef, <2 x i32> <i32 2, i32 3>
  %4 = shufflevector <4 x double> %v2, <4 x double> undef, <2 x i32> <i32 2, i32 3>
  %5 = tail call <2 x double> @llvm.kvx.fadddp(<2 x double> %3, <2 x double> %4, i32 0)
  %6 = shufflevector <2 x double> %2, <2 x double> %5, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  ret <4 x double> %6
}

define <2 x float> @faddcwc(<2 x float> %v1, <2 x float> %v2){
; CHECK-LABEL: faddcwc:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    faddcwc.rn $r0 = $r0, $r0
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = tail call <2 x float> @llvm.kvx.faddcwc(<2 x float> %v1, <2 x float> %v1, i32 0)
  ret <2 x float> %0
}

declare <2 x float> @llvm.kvx.faddcwc(<2 x float>, <2 x float>, i32) #1

define <4 x float> @faddcwcp(<4 x float> %v1, <4 x float> %v2){
; CHECK-LABEL: faddcwcp:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    faddcwcp.rn $r0r1 = $r0r1, $r2r3
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = tail call <4 x float> @llvm.kvx.faddcwcp(<4 x float> %v1, <4 x float> %v2, i32 0)
  ret <4 x float> %0
}

declare <4 x float> @llvm.kvx.faddcwcp(<4 x float>, <4 x float>, i32) #1

define <8 x float> @faddcwcq(<8 x float> %v1, <8 x float> %v2){
; CHECK-LABEL: faddcwcq:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    faddcwcp.rn $r0r1 = $r0r1, $r4r5
; CHECK-NEXT:    ;;
; CHECK-NEXT:    faddcwcp.rn $r2r3 = $r2r3, $r6r7
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = shufflevector <8 x float> %v1, <8 x float> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  %1 = shufflevector <8 x float> %v2, <8 x float> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  %2 = tail call <4 x float> @llvm.kvx.faddcwcp(<4 x float> %0, <4 x float> %1, i32 0)
  %3 = shufflevector <8 x float> %v1, <8 x float> undef, <4 x i32> <i32 4, i32 5, i32 6, i32 7>
  %4 = shufflevector <8 x float> %v2, <8 x float> undef, <4 x i32> <i32 4, i32 5, i32 6, i32 7>
  %5 = tail call <4 x float> @llvm.kvx.faddcwcp(<4 x float> %3, <4 x float> %4, i32 0)
  %6 = shufflevector <4 x float> %2, <4 x float> %5, <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7>
  ret <8 x float> %6
}

define <2 x double> @faddcdc(<2 x double> %v1, <2 x double> %v2){
; CHECK-LABEL: faddcdc:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    faddcdc.rn $r0r1 = $r0r1, $r2r3
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = tail call <2 x double> @llvm.kvx.faddcdc(<2 x double> %v1, <2 x double> %v2, i32 0)
  ret <2 x double> %0
}

declare <2 x double> @llvm.kvx.faddcdc(<2 x double>, <2 x double>, i32) #1

define <4 x double> @faddcdcp(<4 x double> %v1, <4 x double> %v2){
; CHECK-LABEL: faddcdcp:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    faddcdc.rn $r0r1 = $r0r1, $r4r5
; CHECK-NEXT:    ;;
; CHECK-NEXT:    faddcdc.rn $r2r3 = $r2r3, $r6r7
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = shufflevector <4 x double> %v1, <4 x double> undef, <2 x i32> <i32 0, i32 1>
  %1 = shufflevector <4 x double> %v2, <4 x double> undef, <2 x i32> <i32 0, i32 1>
  %2 = tail call <2 x double> @llvm.kvx.faddcdc(<2 x double> %0, <2 x double> %1, i32 0)
  %3 = shufflevector <4 x double> %v1, <4 x double> undef, <2 x i32> <i32 2, i32 3>
  %4 = shufflevector <4 x double> %v2, <4 x double> undef, <2 x i32> <i32 2, i32 3>
  %5 = tail call <2 x double> @llvm.kvx.faddcdc(<2 x double> %3, <2 x double> %4, i32 0)
  %6 = shufflevector <2 x double> %2, <2 x double> %5, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  ret <4 x double> %6
}

define <2 x float> @fsbfwp(<2 x float> %v1, <2 x float> %v2){
; CHECK-LABEL: fsbfwp:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    fsbfwp.rn $r0 = $r0, $r1
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = tail call <2 x float> @llvm.kvx.fsbfwp(<2 x float> %v1, <2 x float> %v2, i32 0)
  ret <2 x float> %0
}

declare <2 x float> @llvm.kvx.fsbfwp(<2 x float>, <2 x float>, i32) #1

define <4 x float> @fsbfwq(<4 x float> %v1, <4 x float> %v2){
; CHECK-LABEL: fsbfwq:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    fsbfwq.rn $r0r1 = $r0r1, $r2r3
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = tail call <4 x float> @llvm.kvx.fsbfwq(<4 x float> %v1, <4 x float> %v2, i32 0)
  ret <4 x float> %0
}

declare <4 x float> @llvm.kvx.fsbfwq(<4 x float>, <4 x float>, i32) #1

define <8 x float> @fsbfwo(<8 x float> %v1, <8 x float> %v2){
; CHECK-LABEL: fsbfwo:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    fsbfwq.rn $r0r1 = $r0r1, $r4r5
; CHECK-NEXT:    ;;
; CHECK-NEXT:    fsbfwq.rn $r2r3 = $r2r3, $r6r7
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = shufflevector <8 x float> %v1, <8 x float> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  %1 = shufflevector <8 x float> %v2, <8 x float> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  %2 = tail call <4 x float> @llvm.kvx.fsbfwq(<4 x float> %0, <4 x float> %1, i32 0)
  %3 = shufflevector <8 x float> %v1, <8 x float> undef, <4 x i32> <i32 4, i32 5, i32 6, i32 7>
  %4 = shufflevector <8 x float> %v2, <8 x float> undef, <4 x i32> <i32 4, i32 5, i32 6, i32 7>
  %5 = tail call <4 x float> @llvm.kvx.fsbfwq(<4 x float> %3, <4 x float> %4, i32 0)
  %6 = shufflevector <4 x float> %2, <4 x float> %5, <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7>
  ret <8 x float> %6
}

define <2 x double> @fsbfdp(<2 x double> %v1, <2 x double> %v2){
; CHECK-LABEL: fsbfdp:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    fsbfdp.rn $r0r1 = $r0r1, $r2r3
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = tail call <2 x double> @llvm.kvx.fsbfdp(<2 x double> %v1, <2 x double> %v2, i32 0)
  ret <2 x double> %0
}

declare <2 x double> @llvm.kvx.fsbfdp(<2 x double>, <2 x double>, i32) #1

define <4 x double> @fsbfdq(<4 x double> %v1, <4 x double> %v2){
; CHECK-LABEL: fsbfdq:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    fsbfdp.rn $r0r1 = $r0r1, $r4r5
; CHECK-NEXT:    ;;
; CHECK-NEXT:    fsbfdp.rn $r2r3 = $r2r3, $r6r7
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = shufflevector <4 x double> %v1, <4 x double> undef, <2 x i32> <i32 0, i32 1>
  %1 = shufflevector <4 x double> %v2, <4 x double> undef, <2 x i32> <i32 0, i32 1>
  %2 = tail call <2 x double> @llvm.kvx.fsbfdp(<2 x double> %0, <2 x double> %1, i32 0)
  %3 = shufflevector <4 x double> %v1, <4 x double> undef, <2 x i32> <i32 2, i32 3>
  %4 = shufflevector <4 x double> %v2, <4 x double> undef, <2 x i32> <i32 2, i32 3>
  %5 = tail call <2 x double> @llvm.kvx.fsbfdp(<2 x double> %3, <2 x double> %4, i32 0)
  %6 = shufflevector <2 x double> %2, <2 x double> %5, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  ret <4 x double> %6
}

define <2 x float> @fsbfcwc(<2 x float> %v1, <2 x float> %v2){
; CHECK-LABEL: fsbfcwc:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    fsbfcwc.rn $r0 = $r0, $r1
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = tail call <2 x float> @llvm.kvx.fsbfcwc(<2 x float> %v1, <2 x float> %v2, i32 0)
  ret <2 x float> %0
}

declare <2 x float> @llvm.kvx.fsbfcwc(<2 x float>, <2 x float>, i32) #1

define <4 x float> @fsbfcwcp(<4 x float> %v1, <4 x float> %v2){
; CHECK-LABEL: fsbfcwcp:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    fsbfcwcp.rn $r0r1 = $r0r1, $r2r3
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = tail call <4 x float> @llvm.kvx.fsbfcwcp(<4 x float> %v1, <4 x float> %v2, i32 0)
  ret <4 x float> %0
}

declare <4 x float> @llvm.kvx.fsbfcwcp(<4 x float>, <4 x float>, i32) #1

define <8 x float> @fsbfcwcq(<8 x float> %v1, <8 x float> %v2){
; CHECK-LABEL: fsbfcwcq:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    fsbfcwcp.rn $r0r1 = $r0r1, $r4r5
; CHECK-NEXT:    ;;
; CHECK-NEXT:    fsbfcwcp.rn $r2r3 = $r2r3, $r6r7
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = shufflevector <8 x float> %v1, <8 x float> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  %1 = shufflevector <8 x float> %v2, <8 x float> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  %2 = tail call <4 x float> @llvm.kvx.fsbfcwcp(<4 x float> %0, <4 x float> %1, i32 0)
  %3 = shufflevector <8 x float> %v1, <8 x float> undef, <4 x i32> <i32 4, i32 5, i32 6, i32 7>
  %4 = shufflevector <8 x float> %v2, <8 x float> undef, <4 x i32> <i32 4, i32 5, i32 6, i32 7>
  %5 = tail call <4 x float> @llvm.kvx.fsbfcwcp(<4 x float> %3, <4 x float> %4, i32 0)
  %6 = shufflevector <4 x float> %2, <4 x float> %5, <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7>
  ret <8 x float> %6
}

define <2 x double> @fsbfcdc(<2 x double> %v1, <2 x double> %v2){
; CHECK-LABEL: fsbfcdc:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    fsbfcdc.rn $r0r1 = $r0r1, $r2r3
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = tail call <2 x double> @llvm.kvx.fsbfcdc(<2 x double> %v1, <2 x double> %v2, i32 0)
  ret <2 x double> %0
}

declare <2 x double> @llvm.kvx.fsbfcdc(<2 x double>, <2 x double>, i32) #1

define <4 x double> @fsbfcdcp(<4 x double> %v1, <4 x double> %v2){
; CHECK-LABEL: fsbfcdcp:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    fsbfcdc.rn $r0r1 = $r0r1, $r4r5
; CHECK-NEXT:    ;;
; CHECK-NEXT:    fsbfcdc.rn $r2r3 = $r2r3, $r6r7
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = shufflevector <4 x double> %v1, <4 x double> undef, <2 x i32> <i32 0, i32 1>
  %1 = shufflevector <4 x double> %v2, <4 x double> undef, <2 x i32> <i32 0, i32 1>
  %2 = tail call <2 x double> @llvm.kvx.fsbfcdc(<2 x double> %0, <2 x double> %1, i32 0)
  %3 = shufflevector <4 x double> %v1, <4 x double> undef, <2 x i32> <i32 2, i32 3>
  %4 = shufflevector <4 x double> %v2, <4 x double> undef, <2 x i32> <i32 2, i32 3>
  %5 = tail call <2 x double> @llvm.kvx.fsbfcdc(<2 x double> %3, <2 x double> %4, i32 0)
  %6 = shufflevector <2 x double> %2, <2 x double> %5, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  ret <4 x double> %6
}

define <2 x float> @fmulwp(<2 x float> %v1, <2 x float> %v2){
; CHECK-LABEL: fmulwp:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    fmulwp.rn $r0 = $r0, $r1
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = tail call <2 x float> @llvm.kvx.fmulwp(<2 x float> %v1, <2 x float> %v2, i32 0)
  ret <2 x float> %0
}

declare <2 x float> @llvm.kvx.fmulwp(<2 x float>, <2 x float>, i32) #1

define <4 x float> @fmulwq(<4 x float> %v1, <4 x float> %v2){
; CHECK-LABEL: fmulwq:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    fmulwq.rn $r0r1 = $r0r1, $r2r3
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = tail call <4 x float> @llvm.kvx.fmulwq(<4 x float> %v1, <4 x float> %v2, i32 0)
  ret <4 x float> %0
}

declare <4 x float> @llvm.kvx.fmulwq(<4 x float>, <4 x float>, i32) #1

define <8 x float> @fmulwo(<8 x float> %v1, <8 x float> %v2){
; CHECK-LABEL: fmulwo:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    fmulwq.rn $r0r1 = $r0r1, $r4r5
; CHECK-NEXT:    ;;
; CHECK-NEXT:    fmulwq.rn $r2r3 = $r2r3, $r6r7
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = shufflevector <8 x float> %v1, <8 x float> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  %1 = shufflevector <8 x float> %v2, <8 x float> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  %2 = tail call <4 x float> @llvm.kvx.fmulwq(<4 x float> %0, <4 x float> %1, i32 0)
  %3 = shufflevector <8 x float> %v1, <8 x float> undef, <4 x i32> <i32 4, i32 5, i32 6, i32 7>
  %4 = shufflevector <8 x float> %v2, <8 x float> undef, <4 x i32> <i32 4, i32 5, i32 6, i32 7>
  %5 = tail call <4 x float> @llvm.kvx.fmulwq(<4 x float> %3, <4 x float> %4, i32 0)
  %6 = shufflevector <4 x float> %2, <4 x float> %5, <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7>
  ret <8 x float> %6
}

define <2 x double> @fmuldp(<2 x double> %v1, <2 x double> %v2){
; CHECK-LABEL: fmuldp:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    fmuld.rn $r0 = $r0, $r2
; CHECK-NEXT:    ;;
; CHECK-NEXT:    fmuld.rn $r1 = $r1, $r3
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = tail call <2 x double> @llvm.kvx.fmuldp(<2 x double> %v1, <2 x double> %v2, i32 0)
  ret <2 x double> %0
}

declare <2 x double> @llvm.kvx.fmuldp(<2 x double>, <2 x double>, i32) #1

define <4 x double> @fmuldq(<4 x double> %v1, <4 x double> %v2){
; CHECK-LABEL: fmuldq:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    fmuld.rn $r0 = $r0, $r4
; CHECK-NEXT:    ;;
; CHECK-NEXT:    fmuld.rn $r1 = $r1, $r5
; CHECK-NEXT:    ;;
; CHECK-NEXT:    fmuld.rn $r2 = $r2, $r6
; CHECK-NEXT:    ;;
; CHECK-NEXT:    fmuld.rn $r3 = $r3, $r7
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = shufflevector <4 x double> %v1, <4 x double> undef, <2 x i32> <i32 0, i32 1>
  %1 = shufflevector <4 x double> %v2, <4 x double> undef, <2 x i32> <i32 0, i32 1>
  %2 = tail call <2 x double> @llvm.kvx.fmuldp(<2 x double> %0, <2 x double> %1, i32 0)
  %3 = shufflevector <4 x double> %v1, <4 x double> undef, <2 x i32> <i32 2, i32 3>
  %4 = shufflevector <4 x double> %v2, <4 x double> undef, <2 x i32> <i32 2, i32 3>
  %5 = tail call <2 x double> @llvm.kvx.fmuldp(<2 x double> %3, <2 x double> %4, i32 0)
  %6 = shufflevector <2 x double> %2, <2 x double> %5, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  ret <4 x double> %6
}

define <2 x float> @fmulwc(<2 x float> %v1, <2 x float> %v2){
; CHECK-LABEL: fmulwc:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    fmulwc.rn $r0 = $r0, $r1
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = tail call <2 x float> @llvm.kvx.fmulwc(<2 x float> %v1, <2 x float> %v2, i32 0)
  ret <2 x float> %0
}

declare <2 x float> @llvm.kvx.fmulwc(<2 x float>, <2 x float>, i32) #1

define <4 x float> @fmulwcp(<4 x float> %v1, <4 x float> %v2){
; CHECK-LABEL: fmulwcp:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    fmulwc.rn $r0 = $r0, $r2
; CHECK-NEXT:    ;;
; CHECK-NEXT:    fmulwc.rn $r1 = $r1, $r3
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = tail call <4 x float> @llvm.kvx.fmulwcp(<4 x float> %v1, <4 x float> %v2, i32 0)
  ret <4 x float> %0
}

declare <4 x float> @llvm.kvx.fmulwcp(<4 x float>, <4 x float>, i32) #1

define <8 x float> @fmulwcq(<8 x float> %v1, <8 x float> %v2){
; CHECK-LABEL: fmulwcq:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    fmulwc.rn $r0 = $r0, $r4
; CHECK-NEXT:    ;;
; CHECK-NEXT:    fmulwc.rn $r1 = $r1, $r5
; CHECK-NEXT:    ;;
; CHECK-NEXT:    fmulwc.rn $r2 = $r2, $r6
; CHECK-NEXT:    ;;
; CHECK-NEXT:    fmulwc.rn $r3 = $r3, $r7
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = shufflevector <8 x float> %v1, <8 x float> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  %1 = shufflevector <8 x float> %v2, <8 x float> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  %2 = tail call <4 x float> @llvm.kvx.fmulwcp(<4 x float> %0, <4 x float> %1, i32 0)
  %3 = shufflevector <8 x float> %v1, <8 x float> undef, <4 x i32> <i32 4, i32 5, i32 6, i32 7>
  %4 = shufflevector <8 x float> %v2, <8 x float> undef, <4 x i32> <i32 4, i32 5, i32 6, i32 7>
  %5 = tail call <4 x float> @llvm.kvx.fmulwcp(<4 x float> %3, <4 x float> %4, i32 0)
  %6 = shufflevector <4 x float> %2, <4 x float> %5, <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7>
  ret <8 x float> %6
}

define <2 x float> @fmulcwc(<2 x float> %v1, <2 x float> %v2){
; CHECK-LABEL: fmulcwc:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    fmulcwc.rn $r0 = $r0, $r1
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = tail call <2 x float> @llvm.kvx.fmulcwc(<2 x float> %v1, <2 x float> %v2, i32 0)
  ret <2 x float> %0
}

declare <2 x float> @llvm.kvx.fmulcwc(<2 x float>, <2 x float>, i32) #1

define <4 x float> @fmulcwcp(<4 x float> %v1, <4 x float> %v2){
; CHECK-LABEL: fmulcwcp:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    fmulcwc.rn $r0 = $r0, $r2
; CHECK-NEXT:    ;;
; CHECK-NEXT:    fmulcwc.rn $r1 = $r1, $r3
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = tail call <4 x float> @llvm.kvx.fmulcwcp(<4 x float> %v1, <4 x float> %v2, i32 0)
  ret <4 x float> %0
}

declare <4 x float> @llvm.kvx.fmulcwcp(<4 x float>, <4 x float>, i32) #1

define <8 x float> @fmulcwcq(<8 x float> %v1, <8 x float> %v2){
; CHECK-LABEL: fmulcwcq:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    fmulcwc.rn $r0 = $r0, $r4
; CHECK-NEXT:    ;;
; CHECK-NEXT:    fmulcwc.rn $r1 = $r1, $r5
; CHECK-NEXT:    ;;
; CHECK-NEXT:    fmulcwc.rn $r2 = $r2, $r6
; CHECK-NEXT:    ;;
; CHECK-NEXT:    fmulcwc.rn $r3 = $r3, $r7
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = shufflevector <8 x float> %v1, <8 x float> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  %1 = shufflevector <8 x float> %v2, <8 x float> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  %2 = tail call <4 x float> @llvm.kvx.fmulcwcp(<4 x float> %0, <4 x float> %1, i32 0)
  %3 = shufflevector <8 x float> %v1, <8 x float> undef, <4 x i32> <i32 4, i32 5, i32 6, i32 7>
  %4 = shufflevector <8 x float> %v2, <8 x float> undef, <4 x i32> <i32 4, i32 5, i32 6, i32 7>
  %5 = tail call <4 x float> @llvm.kvx.fmulcwcp(<4 x float> %3, <4 x float> %4, i32 0)
  %6 = shufflevector <4 x float> %2, <4 x float> %5, <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7>
  ret <8 x float> %6
}

define <2 x double> @fmuldc(<2 x double> %v1, <2 x double> %v2){
; CHECK-LABEL: fmuldc:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    fmuld.rn $r4 = $r0, $r2
; CHECK-NEXT:    ;;
; CHECK-NEXT:    ffmsd.rn $r4 = $r1, $r3
; CHECK-NEXT:    ;;
; CHECK-NEXT:    fmuld.rn $r5 = $r0, $r3
; CHECK-NEXT:    ;;
; CHECK-NEXT:    ffmad.rn $r5 = $r2, $r1
; CHECK-NEXT:    copyd $r0 = $r4
; CHECK-NEXT:    ;;
; CHECK-NEXT:    copyd $r1 = $r5
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = tail call <2 x double> @llvm.kvx.fmuldc(<2 x double> %v1, <2 x double> %v2, i32 0)
  ret <2 x double> %0
}

declare <2 x double> @llvm.kvx.fmuldc(<2 x double>, <2 x double>, i32) #1

define <4 x double> @fmuldcp(<4 x double> %v1, <4 x double> %v2){
; CHECK-LABEL: fmuldcp:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    fmuld.rn $r8 = $r0, $r4
; CHECK-NEXT:    ;;
; CHECK-NEXT:    ffmsd.rn $r8 = $r1, $r5
; CHECK-NEXT:    ;;
; CHECK-NEXT:    fmuld.rn $r9 = $r0, $r5
; CHECK-NEXT:    ;;
; CHECK-NEXT:    ffmad.rn $r9 = $r4, $r1
; CHECK-NEXT:    ;;
; CHECK-NEXT:    fmuld.rn $r4 = $r2, $r6
; CHECK-NEXT:    ;;
; CHECK-NEXT:    ffmsd.rn $r4 = $r3, $r7
; CHECK-NEXT:    ;;
; CHECK-NEXT:    fmuld.rn $r5 = $r2, $r7
; CHECK-NEXT:    ;;
; CHECK-NEXT:    ffmad.rn $r5 = $r6, $r3
; CHECK-NEXT:    copyd $r0 = $r8
; CHECK-NEXT:    copyd $r1 = $r9
; CHECK-NEXT:    copyd $r2 = $r4
; CHECK-NEXT:    ;;
; CHECK-NEXT:    copyd $r3 = $r5
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = shufflevector <4 x double> %v1, <4 x double> undef, <2 x i32> <i32 0, i32 1>
  %1 = shufflevector <4 x double> %v2, <4 x double> undef, <2 x i32> <i32 0, i32 1>
  %2 = tail call <2 x double> @llvm.kvx.fmuldc(<2 x double> %0, <2 x double> %1, i32 0)
  %3 = shufflevector <4 x double> %v1, <4 x double> undef, <2 x i32> <i32 2, i32 3>
  %4 = shufflevector <4 x double> %v2, <4 x double> undef, <2 x i32> <i32 2, i32 3>
  %5 = tail call <2 x double> @llvm.kvx.fmuldc(<2 x double> %3, <2 x double> %4, i32 0)
  %6 = shufflevector <2 x double> %2, <2 x double> %5, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  ret <4 x double> %6
}

define <2 x double> @fmulcdc(<2 x double> %v1, <2 x double> %v2){
; CHECK-LABEL: fmulcdc:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    fmuld.rn $r6 = $r0, $r2
; CHECK-NEXT:    copyd $r4 = $r3
; CHECK-NEXT:    ;;
; CHECK-NEXT:    ffmad.rn $r4 = $r6, $r1
; CHECK-NEXT:    ;;
; CHECK-NEXT:    fmuld.rn $r6 = $r2, $r1
; CHECK-NEXT:    copyd $r5 = $r3
; CHECK-NEXT:    ;;
; CHECK-NEXT:    ffmsd.rn $r5 = $r6, $r0
; CHECK-NEXT:    copyd $r0 = $r4
; CHECK-NEXT:    ;;
; CHECK-NEXT:    copyd $r1 = $r5
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = tail call <2 x double> @llvm.kvx.fmulcdc(<2 x double> %v1, <2 x double> %v2, i32 0)
  ret <2 x double> %0
}

declare <2 x double> @llvm.kvx.fmulcdc(<2 x double>, <2 x double>, i32) #1

define <4 x double> @fmulcdcp(<4 x double> %v1, <4 x double> %v2){
; CHECK-LABEL: fmulcdcp:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    fmuld.rn $r10 = $r0, $r4
; CHECK-NEXT:    copyd $r8 = $r5
; CHECK-NEXT:    ;;
; CHECK-NEXT:    ffmad.rn $r8 = $r10, $r1
; CHECK-NEXT:    ;;
; CHECK-NEXT:    fmuld.rn $r10 = $r4, $r1
; CHECK-NEXT:    copyd $r9 = $r5
; CHECK-NEXT:    ;;
; CHECK-NEXT:    ffmsd.rn $r9 = $r10, $r0
; CHECK-NEXT:    ;;
; CHECK-NEXT:    fmuld.rn $r0 = $r2, $r6
; CHECK-NEXT:    copyd $r4 = $r7
; CHECK-NEXT:    ;;
; CHECK-NEXT:    ffmad.rn $r4 = $r0, $r3
; CHECK-NEXT:    ;;
; CHECK-NEXT:    fmuld.rn $r0 = $r6, $r3
; CHECK-NEXT:    copyd $r5 = $r7
; CHECK-NEXT:    ;;
; CHECK-NEXT:    ffmsd.rn $r5 = $r0, $r2
; CHECK-NEXT:    copyd $r0 = $r8
; CHECK-NEXT:    copyd $r1 = $r9
; CHECK-NEXT:    copyd $r2 = $r4
; CHECK-NEXT:    ;;
; CHECK-NEXT:    copyd $r3 = $r5
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = shufflevector <4 x double> %v1, <4 x double> undef, <2 x i32> <i32 0, i32 1>
  %1 = shufflevector <4 x double> %v2, <4 x double> undef, <2 x i32> <i32 0, i32 1>
  %2 = tail call <2 x double> @llvm.kvx.fmulcdc(<2 x double> %0, <2 x double> %1, i32 0)
  %3 = shufflevector <4 x double> %v1, <4 x double> undef, <2 x i32> <i32 2, i32 3>
  %4 = shufflevector <4 x double> %v2, <4 x double> undef, <2 x i32> <i32 2, i32 3>
  %5 = tail call <2 x double> @llvm.kvx.fmulcdc(<2 x double> %3, <2 x double> %4, i32 0)
  %6 = shufflevector <2 x double> %2, <2 x double> %5, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  ret <4 x double> %6
}

define <4 x float> @fmm212w(<2 x float> %v1, <2 x float> %v2){
; CHECK-LABEL: fmm212w:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    fmm212w.rn $r0r1 = $r0, $r1
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = tail call <4 x float> @llvm.kvx.fmm212w(<2 x float> %v1, <2 x float> %v2, i32 0)
  ret <4 x float> %0
}

declare <4 x float> @llvm.kvx.fmm212w(<2 x float>, <2 x float>, i32) #1

define <4 x float> @fmma212w(<2 x float> %v1, <2 x float> %v2, <4 x float> %v3){
; CHECK-LABEL: fmma212w:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    fmma212w.rn $r2r3 = $r0, $r1
; CHECK-NEXT:    ;;
; CHECK-NEXT:    copyd $r0 = $r2
; CHECK-NEXT:    copyd $r1 = $r3
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = tail call <4 x float> @llvm.kvx.fmma212w(<2 x float> %v1, <2 x float> %v2, <4 x float> %v3, i32 0)
  ret <4 x float> %0
}

declare <4 x float> @llvm.kvx.fmma212w(<2 x float>, <2 x float>, <4 x float>, i32) #1

define <4 x float> @fmms212w(<2 x float> %v1, <2 x float> %v2, <4 x float> %v3){
; CHECK-LABEL: fmms212w:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    fmms212w.rn $r2r3 = $r0, $r1
; CHECK-NEXT:    ;;
; CHECK-NEXT:    copyd $r0 = $r2
; CHECK-NEXT:    copyd $r1 = $r3
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = tail call <4 x float> @llvm.kvx.fmms212w(<2 x float> %v1, <2 x float> %v2, <4 x float> %v3, i32 0)
  ret <4 x float> %0
}

declare <4 x float> @llvm.kvx.fmms212w(<2 x float>, <2 x float>, <4 x float>, i32) #1

define <2 x float> @ffmawp(<2 x float> %v1, <2 x float> %v2, <2 x float> %v3){
; CHECK-LABEL: ffmawp:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    ffmawp.rn $r2 = $r0, $r1
; CHECK-NEXT:    ;;
; CHECK-NEXT:    copyd $r0 = $r2
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = tail call <2 x float> @llvm.kvx.ffmawp(<2 x float> %v1, <2 x float> %v2, <2 x float> %v3, i32 0)
  ret <2 x float> %0
}

declare <2 x float> @llvm.kvx.ffmawp(<2 x float>, <2 x float>, <2 x float>, i32) #1

define <4 x float> @ffmawq(<4 x float> %v1, <4 x float> %v2, <4 x float> %v3){
; CHECK-LABEL: ffmawq:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    ffmawp.rn $r4 = $r0, $r2
; CHECK-NEXT:    ;;
; CHECK-NEXT:    ffmawp.rn $r5 = $r1, $r3
; CHECK-NEXT:    copyd $r0 = $r4
; CHECK-NEXT:    ;;
; CHECK-NEXT:    copyd $r1 = $r5
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = tail call <4 x float> @llvm.kvx.ffmawq(<4 x float> %v1, <4 x float> %v2, <4 x float> %v3, i32 0)
  ret <4 x float> %0
}

declare <4 x float> @llvm.kvx.ffmawq(<4 x float>, <4 x float>, <4 x float>, i32) #1

define <8 x float> @ffmawo(<8 x float> %v1, <8 x float> %v2, <8 x float> %v3){
; CHECK-LABEL: ffmawo:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    ffmawp.rn $r8 = $r0, $r4
; CHECK-NEXT:    ;;
; CHECK-NEXT:    ffmawp.rn $r9 = $r1, $r5
; CHECK-NEXT:    ;;
; CHECK-NEXT:    ffmawp.rn $r10 = $r2, $r6
; CHECK-NEXT:    ;;
; CHECK-NEXT:    ffmawp.rn $r11 = $r3, $r7
; CHECK-NEXT:    copyd $r0 = $r8
; CHECK-NEXT:    copyd $r1 = $r9
; CHECK-NEXT:    copyd $r2 = $r10
; CHECK-NEXT:    ;;
; CHECK-NEXT:    copyd $r3 = $r11
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = shufflevector <8 x float> %v1, <8 x float> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  %1 = shufflevector <8 x float> %v2, <8 x float> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  %2 = shufflevector <8 x float> %v3, <8 x float> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  %3 = tail call <4 x float> @llvm.kvx.ffmawq(<4 x float> %0, <4 x float> %1, <4 x float> %2, i32 0)
  %4 = shufflevector <8 x float> %v1, <8 x float> undef, <4 x i32> <i32 4, i32 5, i32 6, i32 7>
  %5 = shufflevector <8 x float> %v2, <8 x float> undef, <4 x i32> <i32 4, i32 5, i32 6, i32 7>
  %6 = shufflevector <8 x float> %v3, <8 x float> undef, <4 x i32> <i32 4, i32 5, i32 6, i32 7>
  %7 = tail call <4 x float> @llvm.kvx.ffmawq(<4 x float> %4, <4 x float> %5, <4 x float> %6, i32 0)
  %8 = shufflevector <4 x float> %3, <4 x float> %7, <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7>
  ret <8 x float> %8
}

define <2 x double> @ffmadp(<2 x double> %v1, <2 x double> %v2, <2 x double> %v3){
; CHECK-LABEL: ffmadp:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    ffmad.rn $r4 = $r0, $r2
; CHECK-NEXT:    ;;
; CHECK-NEXT:    ffmad.rn $r5 = $r1, $r3
; CHECK-NEXT:    copyd $r0 = $r4
; CHECK-NEXT:    ;;
; CHECK-NEXT:    copyd $r1 = $r5
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = tail call <2 x double> @llvm.kvx.ffmadp(<2 x double> %v1, <2 x double> %v2, <2 x double> %v3, i32 0)
  ret <2 x double> %0
}

declare <2 x double> @llvm.kvx.ffmadp(<2 x double>, <2 x double>, <2 x double>, i32) #1

define <4 x double> @ffmadq(<4 x double> %v1, <4 x double> %v2, <4 x double> %v3){
; CHECK-LABEL: ffmadq:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    ffmad.rn $r8 = $r0, $r4
; CHECK-NEXT:    ;;
; CHECK-NEXT:    ffmad.rn $r9 = $r1, $r5
; CHECK-NEXT:    ;;
; CHECK-NEXT:    ffmad.rn $r10 = $r2, $r6
; CHECK-NEXT:    ;;
; CHECK-NEXT:    ffmad.rn $r11 = $r3, $r7
; CHECK-NEXT:    copyd $r0 = $r8
; CHECK-NEXT:    copyd $r1 = $r9
; CHECK-NEXT:    copyd $r2 = $r10
; CHECK-NEXT:    ;;
; CHECK-NEXT:    copyd $r3 = $r11
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = shufflevector <4 x double> %v1, <4 x double> undef, <2 x i32> <i32 0, i32 1>
  %1 = shufflevector <4 x double> %v2, <4 x double> undef, <2 x i32> <i32 0, i32 1>
  %2 = shufflevector <4 x double> %v3, <4 x double> undef, <2 x i32> <i32 0, i32 1>
  %3 = tail call <2 x double> @llvm.kvx.ffmadp(<2 x double> %0, <2 x double> %1, <2 x double> %2, i32 0)
  %4 = shufflevector <4 x double> %v1, <4 x double> undef, <2 x i32> <i32 2, i32 3>
  %5 = shufflevector <4 x double> %v2, <4 x double> undef, <2 x i32> <i32 2, i32 3>
  %6 = shufflevector <4 x double> %v3, <4 x double> undef, <2 x i32> <i32 2, i32 3>
  %7 = tail call <2 x double> @llvm.kvx.ffmadp(<2 x double> %4, <2 x double> %5, <2 x double> %6, i32 0)
  %8 = shufflevector <2 x double> %3, <2 x double> %7, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  ret <4 x double> %8
}

define <2 x float> @ffmswp(<2 x float> %v1, <2 x float> %v2, <2 x float> %v3){
; CHECK-LABEL: ffmswp:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    ffmswp.rn $r2 = $r0, $r1
; CHECK-NEXT:    ;;
; CHECK-NEXT:    copyd $r0 = $r2
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = tail call <2 x float> @llvm.kvx.ffmswp(<2 x float> %v1, <2 x float> %v2, <2 x float> %v3, i32 0)
  ret <2 x float> %0
}

declare <2 x float> @llvm.kvx.ffmswp(<2 x float>, <2 x float>, <2 x float>, i32) #1

define <4 x float> @ffmswq(<4 x float> %v1, <4 x float> %v2, <4 x float> %v3){
; CHECK-LABEL: ffmswq:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    ffmswp.rn $r4 = $r0, $r2
; CHECK-NEXT:    ;;
; CHECK-NEXT:    ffmswp.rn $r5 = $r1, $r3
; CHECK-NEXT:    copyd $r0 = $r4
; CHECK-NEXT:    ;;
; CHECK-NEXT:    copyd $r1 = $r5
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = tail call <4 x float> @llvm.kvx.ffmswq(<4 x float> %v1, <4 x float> %v2, <4 x float> %v3, i32 0)
  ret <4 x float> %0
}

declare <4 x float> @llvm.kvx.ffmswq(<4 x float>, <4 x float>, <4 x float>, i32) #1

define <8 x float> @ffmswo(<8 x float> %v1, <8 x float> %v2, <8 x float> %v3){
; CHECK-LABEL: ffmswo:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    ffmswp.rn $r8 = $r0, $r4
; CHECK-NEXT:    ;;
; CHECK-NEXT:    ffmswp.rn $r9 = $r1, $r5
; CHECK-NEXT:    ;;
; CHECK-NEXT:    ffmswp.rn $r10 = $r2, $r6
; CHECK-NEXT:    ;;
; CHECK-NEXT:    ffmswp.rn $r11 = $r3, $r7
; CHECK-NEXT:    copyd $r0 = $r8
; CHECK-NEXT:    copyd $r1 = $r9
; CHECK-NEXT:    copyd $r2 = $r10
; CHECK-NEXT:    ;;
; CHECK-NEXT:    copyd $r3 = $r11
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = shufflevector <8 x float> %v1, <8 x float> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  %1 = shufflevector <8 x float> %v2, <8 x float> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  %2 = shufflevector <8 x float> %v3, <8 x float> undef, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  %3 = tail call <4 x float> @llvm.kvx.ffmswq(<4 x float> %0, <4 x float> %1, <4 x float> %2, i32 0)
  %4 = shufflevector <8 x float> %v1, <8 x float> undef, <4 x i32> <i32 4, i32 5, i32 6, i32 7>
  %5 = shufflevector <8 x float> %v2, <8 x float> undef, <4 x i32> <i32 4, i32 5, i32 6, i32 7>
  %6 = shufflevector <8 x float> %v3, <8 x float> undef, <4 x i32> <i32 4, i32 5, i32 6, i32 7>
  %7 = tail call <4 x float> @llvm.kvx.ffmswq(<4 x float> %4, <4 x float> %5, <4 x float> %6, i32 0)
  %8 = shufflevector <4 x float> %3, <4 x float> %7, <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 6, i32 7>
  ret <8 x float> %8
}

define <2 x double> @ffmsdp(<2 x double> %v1, <2 x double> %v2, <2 x double> %v3){
; CHECK-LABEL: ffmsdp:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    ffmsd.rn $r4 = $r0, $r2
; CHECK-NEXT:    ;;
; CHECK-NEXT:    ffmsd.rn $r5 = $r1, $r3
; CHECK-NEXT:    copyd $r0 = $r4
; CHECK-NEXT:    ;;
; CHECK-NEXT:    copyd $r1 = $r5
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = tail call <2 x double> @llvm.kvx.ffmsdp(<2 x double> %v1, <2 x double> %v2, <2 x double> %v3, i32 0)
  ret <2 x double> %0
}

declare <2 x double> @llvm.kvx.ffmsdp(<2 x double>, <2 x double>, <2 x double>, i32) #1

define <4 x double> @ffmsdq(<4 x double> %v1, <4 x double> %v2, <4 x double> %v3){
; CHECK-LABEL: ffmsdq:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    ffmsd.rn $r8 = $r0, $r4
; CHECK-NEXT:    ;;
; CHECK-NEXT:    ffmsd.rn $r9 = $r1, $r5
; CHECK-NEXT:    ;;
; CHECK-NEXT:    ffmsd.rn $r10 = $r2, $r6
; CHECK-NEXT:    ;;
; CHECK-NEXT:    ffmsd.rn $r11 = $r3, $r7
; CHECK-NEXT:    copyd $r0 = $r8
; CHECK-NEXT:    copyd $r1 = $r9
; CHECK-NEXT:    copyd $r2 = $r10
; CHECK-NEXT:    ;;
; CHECK-NEXT:    copyd $r3 = $r11
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = shufflevector <4 x double> %v1, <4 x double> undef, <2 x i32> <i32 0, i32 1>
  %1 = shufflevector <4 x double> %v2, <4 x double> undef, <2 x i32> <i32 0, i32 1>
  %2 = shufflevector <4 x double> %v3, <4 x double> undef, <2 x i32> <i32 0, i32 1>
  %3 = tail call <2 x double> @llvm.kvx.ffmsdp(<2 x double> %0, <2 x double> %1, <2 x double> %2, i32 0)
  %4 = shufflevector <4 x double> %v1, <4 x double> undef, <2 x i32> <i32 2, i32 3>
  %5 = shufflevector <4 x double> %v2, <4 x double> undef, <2 x i32> <i32 2, i32 3>
  %6 = shufflevector <4 x double> %v3, <4 x double> undef, <2 x i32> <i32 2, i32 3>
  %7 = tail call <2 x double> @llvm.kvx.ffmsdp(<2 x double> %4, <2 x double> %5, <2 x double> %6, i32 0)
  %8 = shufflevector <2 x double> %3, <2 x double> %7, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  ret <4 x double> %8
}

define <2 x float> @floatwp(<2 x i32> %v){
; CHECK-LABEL: floatwp:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    floatwp.rn $r0 = $r0, 3
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = tail call <2 x float> @llvm.kvx.floatwp(<2 x i32> %v, i64 3, i32 0)
  ret <2 x float> %0
}

declare <2 x float> @llvm.kvx.floatwp(<2 x i32>, i64, i32) #1

define <4 x float> @floatwq(<4 x i32> %v){
; CHECK-LABEL: floatwq:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    floatwp.rn $r0 = $r0, 3
; CHECK-NEXT:    ;;
; CHECK-NEXT:    floatwp.rn $r1 = $r1, 3
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = shufflevector <4 x i32> %v, <4 x i32> undef, <2 x i32> <i32 0, i32 1>
  %1 = tail call <2 x float> @llvm.kvx.floatwp(<2 x i32> %0, i64 3, i32 0)
  %2 = shufflevector <4 x i32> %v, <4 x i32> undef, <2 x i32> <i32 2, i32 3>
  %3 = tail call <2 x float> @llvm.kvx.floatwp(<2 x i32> %2, i64 3, i32 0)
  %4 = shufflevector <2 x float> %1, <2 x float> %3, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  ret <4 x float> %4
}

define <8 x float> @floatwo(<8 x i32> %v){
; CHECK-LABEL: floatwo:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    floatwp.rn $r0 = $r0, 3
; CHECK-NEXT:    ;;
; CHECK-NEXT:    floatwp.rn $r1 = $r1, 3
; CHECK-NEXT:    ;;
; CHECK-NEXT:    floatwp.rn $r2 = $r2, 3
; CHECK-NEXT:    ;;
; CHECK-NEXT:    floatwp.rn $r3 = $r3, 3
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = shufflevector <8 x i32> %v, <8 x i32> undef, <2 x i32> <i32 0, i32 1>
  %1 = tail call <2 x float> @llvm.kvx.floatwp(<2 x i32> %0, i64 3, i32 0)
  %2 = shufflevector <8 x i32> %v, <8 x i32> undef, <2 x i32> <i32 2, i32 3>
  %3 = tail call <2 x float> @llvm.kvx.floatwp(<2 x i32> %2, i64 3, i32 0)
  %4 = shufflevector <2 x float> %1, <2 x float> %3, <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 undef, i32 undef, i32 undef, i32 undef>
  %5 = shufflevector <8 x i32> %v, <8 x i32> undef, <2 x i32> <i32 4, i32 5>
  %6 = tail call <2 x float> @llvm.kvx.floatwp(<2 x i32> %5, i64 3, i32 0)
  %7 = shufflevector <2 x float> %6, <2 x float> undef, <8 x i32> <i32 0, i32 1, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef>
  %8 = shufflevector <8 x float> %4, <8 x float> %7, <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 8, i32 9, i32 undef, i32 undef>
  %9 = shufflevector <8 x i32> %v, <8 x i32> undef, <2 x i32> <i32 6, i32 7>
  %10 = tail call <2 x float> @llvm.kvx.floatwp(<2 x i32> %9, i64 3, i32 0)
  %11 = shufflevector <2 x float> %10, <2 x float> undef, <8 x i32> <i32 0, i32 1, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef>
  %12 = shufflevector <8 x float> %8, <8 x float> %11, <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 8, i32 9>
  ret <8 x float> %12
}

define <2 x double> @floatdp(<2 x i64> %v){
; CHECK-LABEL: floatdp:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    floatd.rn $r0 = $r0, 3
; CHECK-NEXT:    ;;
; CHECK-NEXT:    floatd.rn $r1 = $r1, 3
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = extractelement <2 x i64> %v, i64 0
  %1 = tail call double @llvm.kvx.floatd(i64 %0, i64 3, i32 0)
  %2 = insertelement <2 x double> undef, double %1, i64 0
  %3 = extractelement <2 x i64> %v, i64 1
  %4 = tail call double @llvm.kvx.floatd(i64 %3, i64 3, i32 0)
  %5 = insertelement <2 x double> %2, double %4, i64 1
  ret <2 x double> %5
}

declare double @llvm.kvx.floatd(i64, i64, i32) #1

define <4 x double> @floatdq(<4 x i64> %v){
; CHECK-LABEL: floatdq:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    floatd.rn $r0 = $r0, 3
; CHECK-NEXT:    ;;
; CHECK-NEXT:    floatd.rn $r1 = $r1, 3
; CHECK-NEXT:    ;;
; CHECK-NEXT:    floatd.rn $r2 = $r2, 3
; CHECK-NEXT:    ;;
; CHECK-NEXT:    floatd.rn $r3 = $r3, 3
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = extractelement <4 x i64> %v, i64 0
  %1 = tail call double @llvm.kvx.floatd(i64 %0, i64 3, i32 0)
  %2 = insertelement <4 x double> undef, double %1, i64 0
  %3 = extractelement <4 x i64> %v, i64 1
  %4 = tail call double @llvm.kvx.floatd(i64 %3, i64 3, i32 0)
  %5 = insertelement <4 x double> %2, double %4, i64 1
  %6 = extractelement <4 x i64> %v, i64 2
  %7 = tail call double @llvm.kvx.floatd(i64 %6, i64 3, i32 0)
  %8 = insertelement <4 x double> %5, double %7, i64 2
  %9 = extractelement <4 x i64> %v, i64 3
  %10 = tail call double @llvm.kvx.floatd(i64 %9, i64 3, i32 0)
  %11 = insertelement <4 x double> %8, double %10, i64 3
  ret <4 x double> %11
}

define <2 x float> @floatuwp(<2 x i32> %v){
; CHECK-LABEL: floatuwp:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    floatuwp.rn $r0 = $r0, 3
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = tail call <2 x float> @llvm.kvx.floatuwp(<2 x i32> %v, i64 3, i32 0)
  ret <2 x float> %0
}

declare <2 x float> @llvm.kvx.floatuwp(<2 x i32>, i64, i32) #1

define <4 x float> @floatuwq(<4 x i32> %v){
; CHECK-LABEL: floatuwq:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    floatuwp.rn $r0 = $r0, 3
; CHECK-NEXT:    ;;
; CHECK-NEXT:    floatuwp.rn $r1 = $r1, 3
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = shufflevector <4 x i32> %v, <4 x i32> undef, <2 x i32> <i32 0, i32 1>
  %1 = tail call <2 x float> @llvm.kvx.floatuwp(<2 x i32> %0, i64 3, i32 0)
  %2 = shufflevector <4 x i32> %v, <4 x i32> undef, <2 x i32> <i32 2, i32 3>
  %3 = tail call <2 x float> @llvm.kvx.floatuwp(<2 x i32> %2, i64 3, i32 0)
  %4 = shufflevector <2 x float> %1, <2 x float> %3, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  ret <4 x float> %4
}

define <8 x float> @floatuwo(<8 x i32> %v){
; CHECK-LABEL: floatuwo:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    floatuwp.rn $r0 = $r0, 3
; CHECK-NEXT:    ;;
; CHECK-NEXT:    floatuwp.rn $r1 = $r1, 3
; CHECK-NEXT:    ;;
; CHECK-NEXT:    floatuwp.rn $r2 = $r2, 3
; CHECK-NEXT:    ;;
; CHECK-NEXT:    floatuwp.rn $r3 = $r3, 3
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = shufflevector <8 x i32> %v, <8 x i32> undef, <2 x i32> <i32 0, i32 1>
  %1 = tail call <2 x float> @llvm.kvx.floatuwp(<2 x i32> %0, i64 3, i32 0)
  %2 = shufflevector <8 x i32> %v, <8 x i32> undef, <2 x i32> <i32 2, i32 3>
  %3 = tail call <2 x float> @llvm.kvx.floatuwp(<2 x i32> %2, i64 3, i32 0)
  %4 = shufflevector <2 x float> %1, <2 x float> %3, <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 undef, i32 undef, i32 undef, i32 undef>
  %5 = shufflevector <8 x i32> %v, <8 x i32> undef, <2 x i32> <i32 4, i32 5>
  %6 = tail call <2 x float> @llvm.kvx.floatuwp(<2 x i32> %5, i64 3, i32 0)
  %7 = shufflevector <2 x float> %6, <2 x float> undef, <8 x i32> <i32 0, i32 1, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef>
  %8 = shufflevector <8 x float> %4, <8 x float> %7, <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 8, i32 9, i32 undef, i32 undef>
  %9 = shufflevector <8 x i32> %v, <8 x i32> undef, <2 x i32> <i32 6, i32 7>
  %10 = tail call <2 x float> @llvm.kvx.floatuwp(<2 x i32> %9, i64 3, i32 0)
  %11 = shufflevector <2 x float> %10, <2 x float> undef, <8 x i32> <i32 0, i32 1, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef>
  %12 = shufflevector <8 x float> %8, <8 x float> %11, <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 8, i32 9>
  ret <8 x float> %12
}

define <2 x double> @floatudp(<2 x i64> %v){
; CHECK-LABEL: floatudp:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    floatud.rn $r0 = $r0, 3
; CHECK-NEXT:    ;;
; CHECK-NEXT:    floatud.rn $r1 = $r1, 3
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = extractelement <2 x i64> %v, i64 0
  %1 = tail call double @llvm.kvx.floatud(i64 %0, i64 3, i32 0)
  %2 = insertelement <2 x double> undef, double %1, i64 0
  %3 = extractelement <2 x i64> %v, i64 1
  %4 = tail call double @llvm.kvx.floatud(i64 %3, i64 3, i32 0)
  %5 = insertelement <2 x double> %2, double %4, i64 1
  ret <2 x double> %5
}

declare double @llvm.kvx.floatud(i64, i64, i32) #1

define <4 x double> @floatudq(<4 x i64> %v){
; CHECK-LABEL: floatudq:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    floatud.rn $r0 = $r0, 3
; CHECK-NEXT:    ;;
; CHECK-NEXT:    floatud.rn $r1 = $r1, 3
; CHECK-NEXT:    ;;
; CHECK-NEXT:    floatud.rn $r2 = $r2, 3
; CHECK-NEXT:    ;;
; CHECK-NEXT:    floatud.rn $r3 = $r3, 3
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = extractelement <4 x i64> %v, i64 0
  %1 = tail call double @llvm.kvx.floatud(i64 %0, i64 3, i32 0)
  %2 = insertelement <4 x double> undef, double %1, i64 0
  %3 = extractelement <4 x i64> %v, i64 1
  %4 = tail call double @llvm.kvx.floatud(i64 %3, i64 3, i32 0)
  %5 = insertelement <4 x double> %2, double %4, i64 1
  %6 = extractelement <4 x i64> %v, i64 2
  %7 = tail call double @llvm.kvx.floatud(i64 %6, i64 3, i32 0)
  %8 = insertelement <4 x double> %5, double %7, i64 2
  %9 = extractelement <4 x i64> %v, i64 3
  %10 = tail call double @llvm.kvx.floatud(i64 %9, i64 3, i32 0)
  %11 = insertelement <4 x double> %8, double %10, i64 3
  ret <4 x double> %11
}

define <2 x i32> @fixedwp(<2 x float> %v){
; CHECK-LABEL: fixedwp:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    fixedwp.rn $r0 = $r0, 3
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = tail call <2 x i32> @llvm.kvx.fixedwp(<2 x float> %v, i64 3, i32 0)
  ret <2 x i32> %0
}

declare <2 x i32> @llvm.kvx.fixedwp(<2 x float>, i64, i32) #1

define <4 x i32> @fixedwq(<4 x float> %v){
; CHECK-LABEL: fixedwq:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    fixedwp.rn $r0 = $r0, 3
; CHECK-NEXT:    ;;
; CHECK-NEXT:    fixedwp.rn $r1 = $r1, 3
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = shufflevector <4 x float> %v, <4 x float> undef, <2 x i32> <i32 0, i32 1>
  %1 = tail call <2 x i32> @llvm.kvx.fixedwp(<2 x float> %0, i64 3, i32 0)
  %2 = shufflevector <4 x float> %v, <4 x float> undef, <2 x i32> <i32 2, i32 3>
  %3 = tail call <2 x i32> @llvm.kvx.fixedwp(<2 x float> %2, i64 3, i32 0)
  %4 = shufflevector <2 x i32> %1, <2 x i32> %3, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  ret <4 x i32> %4
}

define <8 x i32> @fixedwo(<8 x float> %v){
; CHECK-LABEL: fixedwo:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    fixedwp.rn $r0 = $r0, 3
; CHECK-NEXT:    ;;
; CHECK-NEXT:    fixedwp.rn $r1 = $r1, 3
; CHECK-NEXT:    ;;
; CHECK-NEXT:    fixedwp.rn $r2 = $r2, 3
; CHECK-NEXT:    ;;
; CHECK-NEXT:    fixedwp.rn $r3 = $r3, 3
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = shufflevector <8 x float> %v, <8 x float> undef, <2 x i32> <i32 0, i32 1>
  %1 = tail call <2 x i32> @llvm.kvx.fixedwp(<2 x float> %0, i64 3, i32 0)
  %2 = shufflevector <8 x float> %v, <8 x float> undef, <2 x i32> <i32 2, i32 3>
  %3 = tail call <2 x i32> @llvm.kvx.fixedwp(<2 x float> %2, i64 3, i32 0)
  %4 = shufflevector <2 x i32> %1, <2 x i32> %3, <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 undef, i32 undef, i32 undef, i32 undef>
  %5 = shufflevector <8 x float> %v, <8 x float> undef, <2 x i32> <i32 4, i32 5>
  %6 = tail call <2 x i32> @llvm.kvx.fixedwp(<2 x float> %5, i64 3, i32 0)
  %7 = shufflevector <2 x i32> %6, <2 x i32> undef, <8 x i32> <i32 0, i32 1, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef>
  %8 = shufflevector <8 x i32> %4, <8 x i32> %7, <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 8, i32 9, i32 undef, i32 undef>
  %9 = shufflevector <8 x float> %v, <8 x float> undef, <2 x i32> <i32 6, i32 7>
  %10 = tail call <2 x i32> @llvm.kvx.fixedwp(<2 x float> %9, i64 3, i32 0)
  %11 = shufflevector <2 x i32> %10, <2 x i32> undef, <8 x i32> <i32 0, i32 1, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef>
  %12 = shufflevector <8 x i32> %8, <8 x i32> %11, <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 8, i32 9>
  ret <8 x i32> %12
}

define <2 x double> @fixeddp(<2 x i64> %v){
; CHECK-LABEL: fixeddp:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    fixedd.rn $r2 = $r0, 3
; CHECK-NEXT:    ;;
; CHECK-NEXT:    fixedd.rn $r3 = $r1, 3
; CHECK-NEXT:    copyd $r0 = $r2
; CHECK-NEXT:    ;;
; CHECK-NEXT:    copyd $r1 = $r3
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = bitcast <2 x i64> %v to <2 x double>
  %1 = extractelement <2 x double> %0, i64 0
  %2 = tail call i64 @llvm.kvx.fixedd(double %1, i64 3, i32 0)
  %3 = insertelement <2 x i64> undef, i64 %2, i64 0
  %4 = extractelement <2 x double> %0, i64 1
  %5 = tail call i64 @llvm.kvx.fixedd(double %4, i64 3, i32 0)
  %6 = insertelement <2 x i64> %3, i64 %5, i64 1
  %7 = bitcast <2 x i64> %6 to <2 x double>
  ret <2 x double> %7
}

declare i64 @llvm.kvx.fixedd(double, i64, i32) #1

define <4 x double> @fixeddq(<4 x i64> %v){
; CHECK-LABEL: fixeddq:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    fixedd.rn $r4 = $r0, 3
; CHECK-NEXT:    ;;
; CHECK-NEXT:    fixedd.rn $r5 = $r1, 3
; CHECK-NEXT:    ;;
; CHECK-NEXT:    fixedd.rn $r6 = $r2, 3
; CHECK-NEXT:    ;;
; CHECK-NEXT:    fixedd.rn $r7 = $r3, 3
; CHECK-NEXT:    copyd $r0 = $r4
; CHECK-NEXT:    copyd $r1 = $r5
; CHECK-NEXT:    copyd $r2 = $r6
; CHECK-NEXT:    ;;
; CHECK-NEXT:    copyd $r3 = $r7
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = bitcast <4 x i64> %v to <4 x double>
  %1 = extractelement <4 x double> %0, i64 0
  %2 = tail call i64 @llvm.kvx.fixedd(double %1, i64 3, i32 0)
  %3 = insertelement <4 x i64> undef, i64 %2, i64 0
  %4 = extractelement <4 x double> %0, i64 1
  %5 = tail call i64 @llvm.kvx.fixedd(double %4, i64 3, i32 0)
  %6 = insertelement <4 x i64> %3, i64 %5, i64 1
  %7 = extractelement <4 x double> %0, i64 2
  %8 = tail call i64 @llvm.kvx.fixedd(double %7, i64 3, i32 0)
  %9 = insertelement <4 x i64> %6, i64 %8, i64 2
  %10 = extractelement <4 x double> %0, i64 3
  %11 = tail call i64 @llvm.kvx.fixedd(double %10, i64 3, i32 0)
  %12 = insertelement <4 x i64> %9, i64 %11, i64 3
  %13 = bitcast <4 x i64> %12 to <4 x double>
  ret <4 x double> %13
}

define <2 x i32> @fixeduwp(<2 x float> %v){
; CHECK-LABEL: fixeduwp:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    fixeduwp.rn $r0 = $r0, 3
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = tail call <2 x i32> @llvm.kvx.fixeduwp(<2 x float> %v, i64 3, i32 0)
  ret <2 x i32> %0
}

declare <2 x i32> @llvm.kvx.fixeduwp(<2 x float>, i64, i32) #1

define <4 x i32> @fixeduwq(<4 x float> %v){
; CHECK-LABEL: fixeduwq:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    fixeduwp.rn $r0 = $r0, 3
; CHECK-NEXT:    ;;
; CHECK-NEXT:    fixeduwp.rn $r1 = $r1, 3
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = shufflevector <4 x float> %v, <4 x float> undef, <2 x i32> <i32 0, i32 1>
  %1 = tail call <2 x i32> @llvm.kvx.fixeduwp(<2 x float> %0, i64 3, i32 0)
  %2 = shufflevector <4 x float> %v, <4 x float> undef, <2 x i32> <i32 2, i32 3>
  %3 = tail call <2 x i32> @llvm.kvx.fixeduwp(<2 x float> %2, i64 3, i32 0)
  %4 = shufflevector <2 x i32> %1, <2 x i32> %3, <4 x i32> <i32 0, i32 1, i32 2, i32 3>
  ret <4 x i32> %4
}

define <8 x i32> @fixeduwo(<8 x float> %v){
; CHECK-LABEL: fixeduwo:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    fixeduwp.rn $r0 = $r0, 3
; CHECK-NEXT:    ;;
; CHECK-NEXT:    fixeduwp.rn $r1 = $r1, 3
; CHECK-NEXT:    ;;
; CHECK-NEXT:    fixeduwp.rn $r2 = $r2, 3
; CHECK-NEXT:    ;;
; CHECK-NEXT:    fixeduwp.rn $r3 = $r3, 3
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = shufflevector <8 x float> %v, <8 x float> undef, <2 x i32> <i32 0, i32 1>
  %1 = tail call <2 x i32> @llvm.kvx.fixeduwp(<2 x float> %0, i64 3, i32 0)
  %2 = shufflevector <8 x float> %v, <8 x float> undef, <2 x i32> <i32 2, i32 3>
  %3 = tail call <2 x i32> @llvm.kvx.fixeduwp(<2 x float> %2, i64 3, i32 0)
  %4 = shufflevector <2 x i32> %1, <2 x i32> %3, <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 undef, i32 undef, i32 undef, i32 undef>
  %5 = shufflevector <8 x float> %v, <8 x float> undef, <2 x i32> <i32 4, i32 5>
  %6 = tail call <2 x i32> @llvm.kvx.fixeduwp(<2 x float> %5, i64 3, i32 0)
  %7 = shufflevector <2 x i32> %6, <2 x i32> undef, <8 x i32> <i32 0, i32 1, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef>
  %8 = shufflevector <8 x i32> %4, <8 x i32> %7, <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 8, i32 9, i32 undef, i32 undef>
  %9 = shufflevector <8 x float> %v, <8 x float> undef, <2 x i32> <i32 6, i32 7>
  %10 = tail call <2 x i32> @llvm.kvx.fixeduwp(<2 x float> %9, i64 3, i32 0)
  %11 = shufflevector <2 x i32> %10, <2 x i32> undef, <8 x i32> <i32 0, i32 1, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef, i32 undef>
  %12 = shufflevector <8 x i32> %8, <8 x i32> %11, <8 x i32> <i32 0, i32 1, i32 2, i32 3, i32 4, i32 5, i32 8, i32 9>
  ret <8 x i32> %12
}

define <2 x double> @fixedudp(<2 x i64> %v){
; CHECK-LABEL: fixedudp:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    fixedud.rn $r2 = $r0, 3
; CHECK-NEXT:    ;;
; CHECK-NEXT:    fixedud.rn $r3 = $r1, 3
; CHECK-NEXT:    copyd $r0 = $r2
; CHECK-NEXT:    ;;
; CHECK-NEXT:    copyd $r1 = $r3
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = bitcast <2 x i64> %v to <2 x double>
  %1 = extractelement <2 x double> %0, i64 0
  %2 = tail call i64 @llvm.kvx.fixedud(double %1, i64 3, i32 0)
  %3 = insertelement <2 x i64> undef, i64 %2, i64 0
  %4 = extractelement <2 x double> %0, i64 1
  %5 = tail call i64 @llvm.kvx.fixedud(double %4, i64 3, i32 0)
  %6 = insertelement <2 x i64> %3, i64 %5, i64 1
  %7 = bitcast <2 x i64> %6 to <2 x double>
  ret <2 x double> %7
}

declare i64 @llvm.kvx.fixedud(double, i64, i32) #1

define <4 x double> @fixedudq(<4 x i64> %v){
; CHECK-LABEL: fixedudq:
; CHECK:       # %bb.0: # %entry
; CHECK-NEXT:    fixedud.rn $r4 = $r0, 3
; CHECK-NEXT:    ;;
; CHECK-NEXT:    fixedud.rn $r5 = $r1, 3
; CHECK-NEXT:    ;;
; CHECK-NEXT:    fixedud.rn $r6 = $r2, 3
; CHECK-NEXT:    ;;
; CHECK-NEXT:    fixedud.rn $r7 = $r3, 3
; CHECK-NEXT:    copyd $r0 = $r4
; CHECK-NEXT:    copyd $r1 = $r5
; CHECK-NEXT:    copyd $r2 = $r6
; CHECK-NEXT:    ;;
; CHECK-NEXT:    copyd $r3 = $r7
; CHECK-NEXT:    ret
; CHECK-NEXT:    ;;
entry:
  %0 = bitcast <4 x i64> %v to <4 x double>
  %1 = extractelement <4 x double> %0, i64 0
  %2 = tail call i64 @llvm.kvx.fixedud(double %1, i64 3, i32 0)
  %3 = insertelement <4 x i64> undef, i64 %2, i64 0
  %4 = extractelement <4 x double> %0, i64 1
  %5 = tail call i64 @llvm.kvx.fixedud(double %4, i64 3, i32 0)
  %6 = insertelement <4 x i64> %3, i64 %5, i64 1
  %7 = extractelement <4 x double> %0, i64 2
  %8 = tail call i64 @llvm.kvx.fixedud(double %7, i64 3, i32 0)
  %9 = insertelement <4 x i64> %6, i64 %8, i64 2
  %10 = extractelement <4 x double> %0, i64 3
  %11 = tail call i64 @llvm.kvx.fixedud(double %10, i64 3, i32 0)
  %12 = insertelement <4 x i64> %9, i64 %11, i64 3
  %13 = bitcast <4 x i64> %12 to <4 x double>
  ret <4 x double> %13
}

